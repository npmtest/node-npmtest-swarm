{"/home/travis/build/npmtest/node-npmtest-swarm/test.js":"/* istanbul instrument in package npmtest_swarm */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-swarm/lib.npmtest_swarm.js":"/* istanbul instrument in package npmtest_swarm */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_swarm = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_swarm = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-swarm/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-swarm && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_swarm */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_swarm\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_swarm.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_swarm.rollup.js'] =\n            local.assetsDict['/assets.npmtest_swarm.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_swarm.__dirname + '/lib.npmtest_swarm.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-swarm/node_modules/swarm/lib/NodeServer.js":"\"use strict\";\n\nvar Swarm = {'profile': 'node.js'};\n\nSwarm.env = require('./env');\nSwarm.Spec = require('./Spec');\nSwarm.LongSpec = require('./LongSpec');\nSwarm.Syncable = require('./Syncable');\nSwarm.Model = require('./Model');\nSwarm.Set = require('./Set');\nSwarm.Vector = require('./Vector');\nSwarm.Host = require('./Host');\nSwarm.Pipe = require('./Pipe');\nSwarm.Storage = require('./Storage');\nSwarm.FileStorage = require('./FileStorage');\nSwarm.LevelStorage = require('./LevelStorage');\nSwarm.EinarosWSStream = require('./EinarosWSStream');\nSwarm.ReactMixin = require('./ReactMixin');\nSwarm.SecondPreciseClock = require('./SecondPreciseClock');\n\nmodule.exports = Swarm;\n","/home/travis/build/npmtest/node-npmtest-swarm/node_modules/swarm/lib/env.js":"\"use strict\";\n\n/** a really simplistic default hash function */\nfunction djb2Hash(str) {\n    var hash = 5381;\n    for (var i = 0; i < str.length; i++) {\n        hash = ((hash << 5) + hash) + str.charCodeAt(i);\n    }\n    return hash;\n}\n\nvar env = module.exports = {\n    // maps URI schemes to stream implementations\n    streams: {},\n    // the default host\n    localhost: undefined,\n    // whether multiple hosts are allowed in one process\n    // (that is mostly useful for testing)\n    multihost: false,\n    // hash function used for consistent hashing\n    hashfn: djb2Hash,\n\n    log: plain_log,\n    debug: false,\n    trace: false,\n\n    isServer: typeof(navigator) === 'undefined',\n    isBrowser: typeof(navigator) === 'object',\n    isWebKit: false,\n    isGecko: false,\n    isIE: false,\n    clockType: undefined // default\n};\n\nif (typeof(navigator) === 'object') {\n    var agent = navigator.userAgent;\n    env.isWebKit = /AppleWebKit\\/(\\S+)/.test(agent);\n    env.isIE = /MSIE ([^;]+)/.test(agent);\n    env.isGecko = /rv:.* Gecko\\/\\d{8}/.test(agent);\n}\n\nfunction plain_log(spec, val, object) {\n    var method = 'log';\n    switch (spec.op()) {\n    case 'error':\n        method = 'error';\n        break;\n    case 'warn':\n        method = 'warn';\n        break;\n    }\n    console[method](spec.toString(), val, object && object._id,\n            '@' + ((object && object._host && object._host._id) || ''));\n}\n","/home/travis/build/npmtest/node-npmtest-swarm/node_modules/swarm/lib/Spec.js":"\"use strict\";\n\n//  S P E C I F I E R\n//\n//  The Swarm aims to switch fully from the classic HTTP\n//  request-response client-server interaction pattern to continuous\n//  real-time synchronization (WebSocket), possibly involving\n//  client-to-client interaction (WebRTC) and client-side storage\n//  (WebStorage). That demands (a) unification of transfer and storage\n//  where possible and (b) transferring, processing and storing of\n//  fine-grained changes.\n//\n//  That's why we use compound event identifiers named *specifiers*\n//  instead of just regular \"plain\" object ids everyone is so used to.\n//  Our ids have to fully describe the context of every small change as\n//  it is likely to be delivered, processed and stored separately from\n//  the rest of the related state.  For every atomic operation, be it a\n//  field mutation or a method invocation, a specifier contains its\n//  class, object id, a method name and, most importantly, its\n//  version id.\n//\n//  A serialized specifier is a sequence of Base64 tokens each prefixed\n//  with a \"quant\". A quant for a class name is '/', an object id is\n//  prefixed with '#', a method with '.' and a version id with '!'.  A\n//  special quant '+' separates parts of each token.  For example, a\n//  typical version id looks like \"!7AMTc+gritzko\" which corresponds to\n//  a version created on Tue Oct 22 2013 08:05:59 GMT by @gritzko (see\n//  Host.time()).\n//\n//  A full serialized specifier looks like\n//        /TodoItem#7AM0f+gritzko.done!7AMTc+gritzko\n//  (a todo item created by @gritzko was marked 'done' by himself)\n//\n//  Specifiers are stored in strings, but we use a lightweight wrapper\n//  class Spec to parse them easily. A wrapper is immutable as we pass\n//  specifiers around a lot.\n\nfunction Spec(str, quant) {\n    if (str && str.constructor === Spec) {\n        str = str.value;\n    } else { // later we assume value has valid format\n        str = (str || '').toString();\n        if (quant && str.charAt(0) >= '0') {\n            str = quant + str;\n        }\n        if (str.replace(Spec.reQTokExt, '')) {\n            throw new Error('malformed specifier: ' + str);\n        }\n    }\n    this.value = str;\n    this.index = 0;\n}\nmodule.exports = Spec;\n\nSpec.prototype.filter = function (quants) {\n    var filterfn = //typeof(quants)==='function' ? quants :\n                function (token, quant) {\n                    return quants.indexOf(quant) !== -1 ? token : '';\n                };\n    return new Spec(this.value.replace(Spec.reQTokExt, filterfn));\n};\nSpec.pattern = function (spec) {\n    return spec.toString().replace(Spec.reQTokExt, '$1');\n};\nSpec.prototype.isEmpty = function () {\n    return this.value==='';\n};\nSpec.prototype.pattern = function () {\n    return Spec.pattern(this.value);\n};\nSpec.prototype.token = function (quant) {\n    var at = quant ? this.value.indexOf(quant, this.index) : this.index;\n    if (at === -1) {\n        return undefined;\n    }\n    Spec.reQTokExt.lastIndex = at;\n    var m = Spec.reQTokExt.exec(this.value);\n    this.index = Spec.reQTokExt.lastIndex;\n    if (!m) {\n        return undefined;\n    }\n    return {quant: m[1], body: m[2], bare: m[3], ext: m[4]};\n};\nSpec.prototype.get = function specGet(quant) {\n    var i = this.value.indexOf(quant);\n    if (i === -1) {\n        return '';\n    }\n    Spec.reQTokExt.lastIndex = i;\n    var m = Spec.reQTokExt.exec(this.value);\n    return m && m[2];\n};\nSpec.prototype.tok = function specGet(quant) {\n    var i = this.value.indexOf(quant);\n    if (i === -1) { return ''; }\n    Spec.reQTokExt.lastIndex = i;\n    var m = Spec.reQTokExt.exec(this.value);\n    return m && m[0];\n};\nSpec.prototype.has = function specHas(quant) {\n    if (quant.length===1) {\n        return this.value.indexOf(quant) !== -1;\n    } else {\n        var toks = this.value.match(Spec.reQTokExt);\n        return toks.indexOf(quant) !== -1;\n    }\n};\nSpec.prototype.set = function specSet(spec, quant) {\n    var ret = new Spec(spec, quant);\n    var m;\n    Spec.reQTokExt.lastIndex = 0;\n    while (null !== (m = Spec.reQTokExt.exec(this.value))) {\n        if (!ret.has(m[1])) {\n            ret = ret.add(m[0]);\n        }\n    }\n    return ret.sort();\n};\nSpec.prototype.version = function () { return this.get('!'); };\nSpec.prototype.op = function () { return this.get('.'); };\nSpec.prototype.type = function () { return this.get('/'); };\nSpec.prototype.id = function () { return this.get('#'); };\nSpec.prototype.typeid = function () { return this.filter('/#'); };\nSpec.prototype.source = function () { return this.token('!').ext; };\n\nSpec.prototype.sort = function () {\n    function Q(a, b) {\n        var qa = a.charAt(0), qb = b.charAt(0), q = Spec.quants;\n        return (q.indexOf(qa) - q.indexOf(qb)) || (a < b);\n    }\n\n    var split = this.value.match(Spec.reQTokExt);\n    return new Spec(split ? split.sort(Q).join('') : '');\n};\n\nSpec.prototype.add = function (spec, quant) {\n    if (spec.constructor !== Spec) {\n        spec = new Spec(spec, quant);\n    }\n    return new Spec(this.value + spec.value);\n};\nSpec.prototype.toString = function () { return this.value; };\n\n\nSpec.int2base = function (i, padlen) {\n    if (i < 0 || i >= (1 << 30)) {\n        throw new Error('out of range');\n    }\n    var ret = '', togo = padlen || 5;\n    for (; i || (togo > 0); i >>= 6, togo--) {\n        ret = Spec.base64.charAt(i & 63) + ret;\n    }\n    return ret;\n};\n\nSpec.prototype.fits = function (specFilter) {\n    var myToks = this.value.match(Spec.reQTokExt);\n    var filterToks = specFilter.match(Spec.reQTokExt), tok;\n    while (tok=filterToks.pop()) {\n        if (myToks.indexOf(tok) === -1) {\n            return false;\n        }\n    }\n    return true;\n};\n\nSpec.base2int = function (base) {\n    var ret = 0, l = base.match(Spec.re64l);\n    for (var shift = 0; l.length; shift += 6) {\n        ret += Spec.base64.indexOf(l.pop()) << shift;\n    }\n    return ret;\n};\nSpec.parseToken = function (token_body) {\n    Spec.reTokExt.lastIndex = -1;\n    var m = Spec.reTokExt.exec(token_body);\n    if (!m) {\n        return null;\n    }\n    return {bare: m[1], ext: m[2] || 'swarm'}; // FIXME not generic\n};\n\nSpec.base64 = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~';\nSpec.rT = '[0-9A-Za-z_~]{1,80}'; // 60*8 bits is enough for everyone\nSpec.reTok = new RegExp('^'+Spec.rT+'$'); // plain no-extension token\nSpec.re64l = new RegExp('[0-9A-Za-z_~]', 'g');\nSpec.quants = ['/', '#', '!', '.'];\nSpec.rsTokExt = '^(=)(?:\\\\+(=))?$'.replace(/=/g, Spec.rT);\nSpec.reTokExt = new RegExp(Spec.rsTokExt);\nSpec.rsQTokExt = '([/#\\\\.!\\\\*])((=)(?:\\\\+(=))?)'.replace(/=/g, Spec.rT);\nSpec.reQTokExt = new RegExp(Spec.rsQTokExt, 'g');\nSpec.is = function (str) {\n    if (str === null || str === undefined) {\n        return false;\n    }\n    return str.constructor === Spec || '' === str.toString().replace(Spec.reQTokExt, '');\n};\nSpec.as = function (spec) {\n    if (!spec) {\n        return new Spec('');\n    } else {\n        return spec.constructor === Spec ? spec : new Spec(spec);\n    }\n};\n\nSpec.Map = function VersionVectorAsAMap(vec) {\n    this.map = {};\n    if (vec) {\n        this.add(vec);\n    }\n};\nSpec.Map.prototype.add = function (versionVector) {\n    var vec = new Spec(versionVector, '!'), tok;\n    while (undefined !== (tok = vec.token('!'))) {\n        var time = tok.bare, source = tok.ext || 'swarm';\n        if (time > (this.map[source] || '')) {\n            this.map[source] = time;\n        }\n    }\n};\nSpec.Map.prototype.covers = function (version) {\n    Spec.reTokExt.lastIndex = 0;\n    var m = Spec.reTokExt.exec(version);\n    var ts = m[1], src = m[2] || 'swarm';\n    return ts <= (this.map[src] || '');\n};\nSpec.Map.prototype.maxTs = function () {\n    var ts = null,\n        map = this.map;\n    for (var src in map) {\n        if (!ts || ts < map[src]) {\n            ts = map[src];\n        }\n    }\n    return ts;\n};\nSpec.Map.prototype.toString = function (trim) {\n    trim = trim || {top: 10, rot: '0'};\n    var top = trim.top || 10,\n        rot = '!' + (trim.rot || '0'),\n        ret = [],\n        map = this.map;\n    for (var src in map) {\n        ret.push('!' + map[src] + (src === 'swarm' ? '' : '+' + src));\n    }\n    ret.sort().reverse();\n    while (ret.length > top || ret[ret.length - 1] <= rot) {\n        ret.pop();\n    }\n    return ret.join('') || '!0';\n};\n","/home/travis/build/npmtest/node-npmtest-swarm/node_modules/swarm/lib/LongSpec.js":"\"use strict\";\n\nvar Spec = require('./Spec');\n\n/**LongSpec is a Long Specifier, i.e. a string of quant+id tokens that may be\n * indeed very (many megabytes) long.  Ids are compressed using\n * dynamic dictionaries (codebooks) or \"unicode numbers\" (base-32768\n * encoding utilizing Unicode symbols as quasi-binary).  Unicode\n * numbers are particularly handy for encoding timestamps.  LongSpecs\n * may be assigned shared codebooks (2nd parameter); a codebook is an\n * object containing encode/decode tables and some stats, e.g.\n * {en:{'/Type':'/T'}, de:{'/T':'/Type'}}. It is OK to pass an empty object as\n * a codebook; it gets initialized automatically).  */\nvar LongSpec = function (spec, codeBook) {\n    var cb = this.codeBook = codeBook || {en:{},de:{}};\n    if (!cb.en) { cb.en = {}; }\n    if (!cb.de) { // revert en to make de\n        cb.de = {};\n        for(var tok in cb.en) {\n            cb.de[cb.en[tok]] = tok;\n        }\n    }\n    if (!cb.lastCodes) {\n        cb.lastCodes = {'/':0x30,'#':0x30,'!':0x30,'.':0x30,'+':0x30};\n    }\n    // For a larger document, a single LongSpec may be some megabytes long.\n    // As we don't want to rewrite those megabytes on every keypress, we\n    // divide data into chunks.\n    this.chunks = [];\n    this.chunkLengths = [];\n    if (spec) {\n        this.append(spec);\n    }\n};\n\nLongSpec.reQTokEn = /([/#\\!\\.\\+])([0-\\u802f]+)/g;\nLongSpec.reQTok = new RegExp('([/#\\\\.!\\\\*\\\\+])(=)'.replace(/=/g, Spec.rT), 'g');\nLongSpec.rTEn = '[0-\\\\u802f]+';\nLongSpec.reQTokExtEn = new RegExp\n    ('([/#\\\\.!\\\\*])((=)(?:\\\\+(=))?)'.replace(/=/g, LongSpec.rTEn), 'g');\n\n/** Well, for many-MB LongSpecs this may take some time. */\nLongSpec.prototype.toString = function () {\n    var ret = [];\n    for(var i = this.iterator(); !i.end(); i.next()){\n        ret.push(i.decode());\n    }\n    return ret.join('');\n};\n\nLongSpec.prototype.length = function () { // TODO .length ?\n    var len = 0;\n    for(var i=0; i<this.chunks.length; i++) {\n        len += this.chunkLengths[i];\n    }\n    return len;\n};\n\nLongSpec.prototype.charLength = function () {\n    var len = 0;\n    for(var i=0; i<this.chunks.length; i++) {\n        len += this.chunks[i].length;\n    }\n    return len;\n};\n\n//   T O K E N  C O M P R E S S I O N\n\nLongSpec.prototype.allocateCode = function (tok) {\n    var quant = tok.charAt(0);\n    //if (Spec.quants.indexOf(quant)===-1) {throw new Error('invalid token');}\n    var en, cb = this.codeBook, lc = cb.lastCodes;\n    if (lc[quant]<'z'.charCodeAt(0)) { // pick a nice letter\n        for(var i=1; !en && i<tok.length; i++) {\n            var x = tok.charAt(i), e = quant+x;\n            if (!cb.de[e]) {  en = e;  }\n        }\n    }\n    while (!en && lc[quant]<0x802f) {\n        var y = String.fromCharCode(lc[quant]++);\n        var mayUse = quant + y;\n        if ( ! cb.en[mayUse] ) {  en = mayUse;  }\n    }\n    if (!en) {\n        if (tok.length<=3) {\n            throw new Error(\"out of codes\");\n        }\n        en = tok;\n    }\n    cb.en[tok] = en;\n    cb.de[en] = tok;\n    return en;\n};\n\n//  F O R M A T  C O N V E R S I O N\n\n\n/** Always 2-char base2^15 coding for an int (0...2^30-1) */\nLongSpec.int2uni = function (i) {\n    if (i<0 || i>0x7fffffff) { throw new Error('int is out of range'); }\n    return String.fromCharCode( 0x30+(i>>15), 0x30+(i&0x7fff) );\n};\n\nLongSpec.uni2int = function (uni) {\n    if (!/^[0-\\u802f]{2}$/.test(uni)) {\n        throw new Error('invalid unicode number') ;\n    }\n    return ((uni.charCodeAt(0)-0x30)<<15) | (uni.charCodeAt(1)-0x30);\n};\n\n//  I T E R A T O R S\n\n/*  Unfortunately, LongSpec cannot be made a simple array because tokens are\n    not fixed-width in the general case. Some tokens are dictionary-encoded\n    into two-symbol segments, e.g. \".on\" --> \".o\". Other tokens may need 6\n    symbols to encode, e.g. \"!timstse+author~ssn\" -> \"!tss+a\".\n    Also, iterators opportuniatically use sequential compression. Namely,\n    tokens that differ by +1 are collapsed into quant-only sequences:\n    \"!abc+s!abd+s\" -> \"!abc+s!\"\n    So, locating and iterating becomes less-than-trivial. Raw string offsets\n    better not be exposed in the external interface; hence, we need iterators.\n\n    {\n        offset:5,       // char offset in the string (chunk)\n        index:1,        // index of the entry (token)\n        en: \"!\",        // the actual matched token (encoded)\n        chunk:0,        // index of the chunk\n        de: \"!timst00+author~ssn\", // decoded token\n        seqstart: \"!ts0+a\", // first token of the sequence (encoded)\n        seqoffset: 3    // offset in the sequence\n    }\n*/\nLongSpec.Iterator = function Iterator (owner, index) {\n    this.owner = owner;         // our LongSpec\n    /*this.chunk = 0;             // the chunk we are in\n    this.index = -1;            // token index (position \"before the 1st token\")\n    this.chunkIndex = -1;       // token index within the chunk\n    this.prevFull = undefined;  // previous full (non-collapsed) token\n    //  seqStart IS the previous match or prev match is trivial\n    this.prevCollapsed = 0;\n    this.match = null;\n    //this.next();*/\n    this.skip2chunk(0);\n    if (index) {\n        if (index.constructor===LongSpec.Iterator) {\n            index = index.index;\n        }\n        this.skip(index);\n    }\n};\n\n\n// also matches collapsed quant-only tokens\nLongSpec.Iterator.reTok = new RegExp\n    ('([/#\\\\.!\\\\*])((=)(?:\\\\+(=))?)?'.replace(/=/g, LongSpec.rTEn), 'g');\n\n\n/* The method converts a (relatively) verbose Base64 specifier into an\n * internal compressed format.  Compressed tokens are also\n * variable-length; the length of the token depends on the encoding\n * method used.\n * 1 unicode symbol: dictionary-encoded (up to 2^15 entries for each quant),\n * 2 symbols: simple timestamp base-2^15 encoded,\n * 3 symbols: timestamp+seq base-2^15,\n * 4 symbols: long-number base-2^15,\n * 5 symbols and more: unencoded original (fallback).\n * As long as two sequential unicoded entries differ by +1 in the body\n * of the token (quant and extension being the same), we use sequential\n * compression. The token is collapsed (only the quant is left).\n * */\nLongSpec.Iterator.prototype.encode = function encode (de) {\n    var re = Spec.reQTokExt;\n    re.lastIndex = 0;\n    var m=re.exec(de); // this one is de\n    if (!m || m[0].length!==de.length) {throw new Error('malformed token: '+de);}\n    var tok=m[0], quant=m[1], body=m[3], ext=m[4];\n    var pm = this.prevFull; // this one is en\n    var prevTok, prevQuant, prevBody, prevExt;\n    var enBody, enExt;\n    if (pm) {\n        prevTok=pm[0], prevQuant=pm[1], prevBody=pm[3], prevExt=pm[4]?'+'+pm[4]:undefined;\n    }\n    if (ext) {\n        enExt = this.owner.codeBook.en['+'+ext] || this.owner.allocateCode('+'+ext);\n    }\n    var maySeq = pm && quant===prevQuant && enExt===prevExt;\n    var haveSeq=false, seqBody = '';\n    var int1, int2, uni1, uni2;\n    //var expected = head + (counter===-1?'':Spec.int2base(counter+inc,1)) + tail;\n    if ( body.length<=4 ||          // TODO make it a switch\n         (quant in LongSpec.quants2code) ||\n         (tok in this.owner.codeBook.en) ) {  // 1 symbol by the codebook\n\n        enBody = this.owner.codeBook.en[quant+body] ||\n                 this.owner.allocateCode(quant+body);\n        enBody = enBody.substr(1); // FIXME separate codebooks 4 quants\n        if (maySeq) {// seq coding for dictionary-coded\n            seqBody = enBody;\n        }\n    } else if (body.length===5) { // 2-symbol base-2^15\n        var int = Spec.base2int(body);\n        enBody = LongSpec.int2uni(int);\n        if (maySeq && prevBody.length===2) {\n            seqBody = LongSpec.int2uni(int-this.prevCollapsed-1);\n        }\n    } else if (body.length===7) { // 3-symbol base-2^15\n        int1 = Spec.base2int(body.substr(0,5));\n        int2 = Spec.base2int(body.substr(5,2));\n        uni1 = LongSpec.int2uni(int1);\n        uni2 = LongSpec.int2uni(int2).charAt(1);\n        enBody = uni1 + uni2;\n        if (maySeq && prevBody.length===3) {\n            seqBody = uni1 + LongSpec.int2uni(int2-this.prevCollapsed-1).charAt(1);\n        }\n    } else if (body.length===10) { // 4-symbol 60-bit long number\n        int1 = Spec.base2int(body.substr(0,5));\n        int2 = Spec.base2int(body.substr(5,5));\n        uni1 = LongSpec.int2uni(int1);\n        uni2 = LongSpec.int2uni(int2);\n        enBody = uni1 + uni2;\n        if (maySeq && prevBody.length===4) {\n            seqBody = uni1+LongSpec.int2uni(int2-this.prevCollapsed-1);\n        }\n    } else { // verbatim\n        enBody = body;\n        seqBody = enBody;\n    }\n    haveSeq = seqBody===prevBody;\n    return haveSeq ? quant : quant+enBody+(enExt||'');\n};\nLongSpec.quants2code = {'/':1,'.':1};\n\n/** Decode a compressed specifier back into base64. */\nLongSpec.Iterator.prototype.decode = function decode () {\n    if (this.match===null) { return undefined; }\n    var quant = this.match[1];\n    var body = this.match[3];\n    var ext = this.match[4];\n    var pm=this.prevFull, prevTok, prevQuant, prevBody, prevExt;\n    var int1, int2, base1, base2;\n    var de = quant;\n    if (pm) {\n        prevTok=pm[0], prevQuant=pm[1], prevBody=pm[3], prevExt=pm[4];\n    }\n    if (!body) {\n        if (prevBody.length===1) {\n            body = prevBody;\n        } else {\n            var l_1 = prevBody.length-1;\n            var int = prevBody.charCodeAt(l_1);\n            body = prevBody.substr(0,l_1) + String.fromCharCode(int+this.prevCollapsed+1);\n        }\n        ext = prevExt;\n    }\n    switch (body.length) {\n        case 1:\n            de += this.owner.codeBook.de[quant+body].substr(1); // TODO sep codebooks\n            break;\n        case 2:\n            int1 = LongSpec.uni2int(body);\n            base1 = Spec.int2base(int1,5);\n            de += base1;\n            break;\n        case 3:\n            int1 = LongSpec.uni2int(body.substr(0,2));\n            int2 = LongSpec.uni2int('0'+body.charAt(2));\n            base1 = Spec.int2base(int1,5);\n            base2 = Spec.int2base(int2,2);\n            de += base1 + base2;\n            break;\n        case 4:\n            int1 = LongSpec.uni2int(body.substr(0,2));\n            int2 = LongSpec.uni2int(body.substr(2,2));\n            base1 = Spec.int2base(int1,5);\n            base2 = Spec.int2base(int2,5);\n            de += base1 + base2;\n            break;\n        default:\n            de += body;\n            break;\n    }\n    if (ext) {\n        var deExt = this.owner.codeBook.de['+'+ext];\n        de += deExt;\n    }\n    return de;\n};\n\n\nLongSpec.Iterator.prototype.next = function ( ) {\n\n    if (this.end()) {return;}\n\n    var re = LongSpec.Iterator.reTok;\n    re.lastIndex = this.match ? this.match.index+this.match[0].length : 0;\n    var chunk = this.owner.chunks[this.chunk];\n\n    if (chunk.length===re.lastIndex) {\n        this.chunk++;\n        this.chunkIndex = 0;\n        if (this.match && this.match[0].length>0) {\n            this.prevFull = this.match;\n            this.prevCollapsed = 0;\n        } else if (this.match) {\n            this.prevCollapsed++;\n        } else { // empty\n            this.prevFull = undefined;\n            this.prevCollapsed = 0;\n        }\n        this.match = null;\n        this.index ++;\n        if (this.end()) {return;}\n    }\n\n    if (this.match[0].length>1) {\n        this.prevFull = this.match;\n        this.prevCollapsed = 0;\n    } else {\n        this.prevCollapsed++;\n    }\n\n    this.match = re.exec(chunk);\n    this.index++;\n    this.chunkIndex++;\n\n    return this.match[0];\n};\n\n\nLongSpec.Iterator.prototype.end = function () {\n    return this.match===null && this.chunk===this.owner.chunks.length;\n};\n\n\nLongSpec.Iterator.prototype.skip = function ( count ) {\n    // TODO may implement fast-skip of seq-compressed spans\n    var lengths = this.owner.chunkLengths, chunks = this.owner.chunks;\n    count = count || 1;\n    var left = count;\n    var leftInChunk = lengths[this.chunk]-this.chunkIndex;\n    if ( leftInChunk <= count ) { // skip chunks\n        left -= leftInChunk; // skip the current chunk\n        var c=this.chunk+1;    // how many extra chunks to skip\n        while (left>chunks[c] && c<chunks.length) {\n            left-=chunks[++c];\n        }\n        this.skip2chunk(c);\n    }\n    if (this.chunk<chunks.length) {\n        while (left>0) {\n            this.next();\n            left--;\n        }\n    }\n    return count - left;\n};\n\n/** Irrespectively of the current state of the iterator moves it to the\n  * first token in the chunk specified; chunk===undefined moves it to\n  * the end() position (one after the last token). */\nLongSpec.Iterator.prototype.skip2chunk = function ( chunk ) {\n    var chunks = this.owner.chunks;\n    if (chunk===undefined) {chunk=chunks.length;}\n    this.index = 0;\n    for(var c=0; c<chunk; c++) { // TODO perf pick the current value\n        this.index += this.owner.chunkLengths[c];\n    }\n    this.chunkIndex = 0;\n    this.chunk = chunk;\n    var re = LongSpec.Iterator.reTok;\n    if ( chunk < chunks.length ) {\n        re.lastIndex = 0;\n        this.match = re.exec(chunks[this.chunk]);\n    } else {\n        this.match = null;\n    }\n    if (chunk>0) { // (1) chunks must not be empty; (2) a chunk starts with a full token\n        var prev = chunks[chunk-1];\n        var j = 0;\n        while (Spec.quants.indexOf(prev.charAt(prev.length-1-j)) !== -1) { j++; }\n        this.prevCollapsed = j;\n        var k = 0;\n        while (Spec.quants.indexOf(prev.charAt(prev.length-1-j-k))===-1) { k++; }\n        re.lastIndex = prev.length-1-j-k;\n        this.prevFull = re.exec(prev);\n    } else {\n        this.prevFull = undefined;\n        this.prevCollapsed = 0;\n    }\n};\n\nLongSpec.Iterator.prototype.token = function () {\n    return this.decode();\n};\n\n/*LongSpec.Iterator.prototype.de = function () {\n    if (this.match===null) {return undefined;}\n    return this.owner.decode(this.match[0],this.prevFull?this.prevFull[0]:undefined,this.prevCollapsed);\n};*/\n\n/*LongSpec.Iterator.prototype.insertDe = function (de) {\n    var en = this.owner.encode(de,this.prevFull?this.prevFull[0]:undefined,this.prevCollapsed);\n    this.insert(en);\n};*/\n\n\n/** As sequential coding is incapsulated in LongSpec.Iterator, inserts are\n  * done by Iterator as well. */\nLongSpec.Iterator.prototype.insert = function (de) { // insertBefore\n\n    var insStr = this.encode(de);\n\n    var brokenSeq = this.match && this.match[0].length===1;\n\n    var re = LongSpec.Iterator.reTok;\n    var chunks = this.owner.chunks, lengths = this.owner.chunkLengths;\n    if (this.chunk==chunks.length) { // end(), append\n        if (chunks.length>0) {\n            var ind = this.chunk - 1;\n            chunks[ind] += insStr;\n            lengths[ind] ++;\n        } else {\n            chunks.push(insStr);\n            lengths.push(1);\n            this.chunk++;\n        }\n    } else {\n        var chunkStr = chunks[this.chunk];\n        var preEq = chunkStr.substr(0, this.match.index);\n        var postEq = chunkStr.substr(this.match.index);\n        if (brokenSeq) {\n            var me = this.token();\n            this.prevFull = undefined;\n            var en = this.encode(me);\n            chunks[this.chunk] = preEq + insStr + en + postEq.substr(1);\n            re.lastIndex = preEq.length + insStr.length;\n            this.match = re.exec(chunks[this.chunk]);\n        } else {\n            chunks[this.chunk] = preEq + insStr + /**/ postEq;\n            this.match.index += insStr.length;\n        }\n        lengths[this.chunk] ++;\n        this.chunkIndex ++;\n    }\n    this.index ++;\n    if (insStr.length>1) {\n        re.lastIndex = 0;\n        this.prevFull = re.exec(insStr);\n        this.prevCollapsed = 0;\n    } else {\n        this.prevCollapsed++;\n    }\n\n    // may split chunks\n    // may join chunks\n};\n\nLongSpec.Iterator.prototype.insertBlock = function (de) { // insertBefore\n    var re = Spec.reQTokExt;\n    var toks = de.match(re).reverse(), tok;\n    while (tok=toks.pop()) {\n        this.insert(tok);\n    }\n};\n\nLongSpec.Iterator.prototype.erase = function (count) {\n    if (this.end()) {return;}\n    count = count || 1;\n    var chunks = this.owner.chunks;\n    var lengths = this.owner.chunkLengths;\n    // remember offsets\n    var fromChunk = this.chunk;\n    var fromOffset = this.match.index;\n    var fromChunkIndex = this.chunkIndex; // TODO clone USE 2 iterators or i+c\n\n    count = this.skip(count); // checked for runaway skip()\n    // the iterator now is at the first-after-erased pos\n\n    var tillChunk = this.chunk;\n    var tillOffset = this.match ? this.match.index : 0; // end()\n\n    var collapsed = this.match && this.match[0].length===1;\n\n    // splice strings, adjust indexes\n    if (fromChunk===tillChunk) {\n        var chunk = chunks[this.chunk];\n        var pre = chunk.substr(0,fromOffset);\n        var post = chunk.substr(tillOffset);\n        if (collapsed) { // sequence is broken now; needs expansion\n            post = this.token() + post.substr(1);\n        }\n        chunks[this.chunk] = pre + post;\n        lengths[this.chunk] -= count;\n        this.chunkIndex -= count;\n    } else {  // FIXME refac, more tests (+wear)\n        if (fromOffset===0) {\n            fromChunk--;\n        } else {\n            chunks[fromChunk] = chunks[fromChunk].substr(0,fromOffset);\n            lengths[fromChunk] = fromChunkIndex;\n        }\n        var midChunks = tillChunk - fromChunk - 1;\n        if (midChunks) { // wipe'em out\n            //for(var c=fromChunk+1; c<tillChunk; c++) ;\n            chunks.splice(fromChunk+1,midChunks);\n            lengths.splice(fromChunk+1,midChunks);\n        }\n        if (tillChunk<chunks.length && tillOffset>0) {\n            chunks[tillChunk] = chunks[tillChunk].substr(this.match.index);\n            lengths[tillChunk] -= this.chunkIndex;\n            this.chunkIndex = 0;\n        }\n    }\n    this.index -= count;\n\n};\n\n\nLongSpec.Iterator.prototype.clone = function () {\n    var copy = new LongSpec.Iterator(this.owner);\n    copy.chunk = this.chunk;\n    copy.match = this.match;\n    copy.index = this.index;\n};\n\n//  L O N G S P E C  A P I\n\nLongSpec.prototype.iterator = function (index) {\n    return new LongSpec.Iterator(this,index);\n};\n\nLongSpec.prototype.end = function () {\n    var e = new LongSpec.Iterator(this);\n    e.skip2chunk(this.chunks.length);\n    return e;\n};\n\n/** Insert a token at a given position. */\nLongSpec.prototype.insert = function (tok, i) {\n    var iter = i.constructor===LongSpec.Iterator ? i : this.iterator(i);\n    iter.insertBlock(tok);\n};\n\nLongSpec.prototype.tokenAt = function (pos) {\n    var iter = this.iterator(pos);\n    return iter.token();\n};\n\nLongSpec.prototype.indexOf = function (tok, startAt) {\n    var iter = this.find(tok,startAt);\n    return iter.end() ? -1 : iter.index;\n};\n\n/*LongSpec.prototype.insertAfter = function (tok, i) {\n    LongSpec.reQTokExtEn.lastIndex = i;\n    var m = LongSpec.reQTokExtEn.exec(this.value);\n    if (m.index!==i) { throw new Error('incorrect position'); }\n    var splitAt = i+m[0].length;\n    this.insertBefore(tok,splitAt);\n};*/\n\nLongSpec.prototype.add = function ls_add (spec) {\n    var pos = this.end();\n    pos.insertBlock(spec);\n};\nLongSpec.prototype.append = LongSpec.prototype.add;\n\n/** The method finds the first occurence of a token, returns an\n * iterator.  While the internal format of an iterator is kind of\n * opaque, and generally is not recommended to rely on, that is\n * actually a regex match array. Note that it contains encoded tokens.\n * The second parameter is the position to start scanning from, passed\n * either as an iterator or an offset. */\nLongSpec.prototype.find = function (tok, startIndex) {\n    //var en = this.encode(tok).toString(); // don't split on +\n    var i = this.iterator(startIndex);\n    while (!i.end()) {\n        if (i.token()===tok) {\n            return i;\n        }\n        i.next();\n    }\n    return i;\n};\n\nmodule.exports = LongSpec;\n","/home/travis/build/npmtest/node-npmtest-swarm/node_modules/swarm/lib/Syncable.js":"\"use strict\";\n\nvar Spec = require('./Spec');\nvar env = require('./env');\n\n/**\n * Syncable: an oplog-synchronized object\n * @constructor\n */\nfunction Syncable() {\n    // listeners represented as objects that have deliver() method\n    this._lstn = [',']; // we unshift() uplink listeners and push() downlinks\n    // ...so _lstn is like [server1, server2, storage, ',', view, listener]\n    // The most correct way to specify a version is the version vector,\n    // but that one may consume more space than the data itself in some cases.\n    // Hence, _version is not a fully specified version vector (see version()\n    // instead). _version is essentially is the greatest operation timestamp\n    // (Lamport-like, i.e. \"time+source\"), sometimes amended with additional\n    // timestamps. Its main features:\n    // (1) changes once the object's state changes\n    // (2) does it monotonically (in the alphanum order sense)\n    this._version = '';\n    // make sense of arguments\n    var args = Array.prototype.slice.call(arguments);\n    this._host = (args.length && args[args.length - 1]._type === 'Host') ?\n            args.pop() : env.localhost;\n    if (Spec.is(args[0])) {\n        this._id = new Spec(args.shift()).id() || this._host.time();\n    } else if (typeof(args[0]) === 'string') {\n        this._id = args.shift(); // TODO format\n    } else {\n        this._id = this._host.time();\n        this._version = '!0'; // may apply state in the constructor, see Model\n    }\n    //var state = args.length ? args.pop() : (fresh?{}:undefined);\n    // register with the host\n    var doubl = this._host.register(this);\n    if (doubl !== this) { return doubl; }\n    // locally created objects get state immediately\n    // (while external-id objects need to query uplinks)\n    /*if (fresh && state) {\n     state._version = '!'+this._id;\n     var pspec = this.spec().add(state._version).add('.init');\n     this.deliver(pspec,state,this._host);\n     }*/\n    this.reset();\n    // find uplinks, subscribe\n    this.checkUplink();\n    // TODO inplement state push\n    return this;\n}\nmodule.exports = Syncable;\n\nSyncable.types = {};\nSyncable.isOpSink = function (obj) {\n    if (!obj) { return false; }\n    if (obj.constructor === Function) { return true; }\n    if (obj.deliver && obj.deliver.constructor === Function) { return true; }\n    return false;\n};\nSyncable.reMethodName = /^[a-z][a-z0-9]*([A-Z][a-z0-9]*)*$/;\nSyncable.memberClasses = {ops:1,neutrals:1,remotes:1,defaults:1,reactions:1,mixins:1};\nSyncable._default = {};\n\nfunction fnname(fn) {\n    if (fn.name) { return fn.name; }\n    return fn.toString().match(/^function\\s*([^\\s(]+)/)[1];\n}\n\n\n/**\n * All CRDT model classes must extend syncable directly or indirectly. Syncable\n * provides all the necessary oplog- and state-related primitives and methods.\n * Every state-mutating method should be explicitly declared to be wrapped\n * by extend() (see 'ops', 'neutrals', 'remotes' sections in class declaration).\n * @param {function|string} fn\n * @param {{ops:object, neutrals:object, remotes:object}} own\n */\nSyncable.extend = function (fn, own) {\n    var parent = this, fnid;\n    if (fn.constructor !== Function) {\n        var id = fn.toString();\n        fn = function SomeSyncable() {\n            return parent.apply(this, arguments);\n        };\n        fnid = id; // if only it worked\n    } else { // please call Syncable.constructor.apply(this,args) in your constructor\n        fnid = fnname(fn);\n    }\n\n    // inheritance trick from backbone.js\n    var SyncProto = function () {\n        this.constructor = fn;\n        this._neutrals = {};\n        this._ops = {};\n        this._reactions = {};\n\n        var event,\n            name;\n        if (parent._pt) {\n            //copy _neutrals & _ops from parent\n            for (event in parent._pt._neutrals) {\n                this._neutrals[event] = parent._pt._neutrals[event];\n            }\n            for (event in parent._pt._ops) {\n                this._ops[event] = parent._pt._ops[event];\n            }\n        }\n\n        // \"Methods\" are serialized, logged and delivered to replicas\n        for (name in own.ops || {}) {\n            if (Syncable.reMethodName.test(name)) {\n                this._ops[name] = own.ops[name];\n                this[name] = wrapCall(name);\n            } else {\n                console.warn('invalid op name:',name);\n            }\n        }\n\n        // \"Neutrals\" don't change the state\n        for (name in own.neutrals || {}) {\n            if (Syncable.reMethodName.test(name)) {\n                this._neutrals[name] = own.neutrals[name];\n                this[name] = wrapCall(name);\n            } else {\n                console.warn('invalid neutral op name:',name);\n            }\n        }\n\n        // \"Remotes\" are serialized and sent upstream (like RPC calls)\n        for (name in own.remotes || {}) {\n            if (Syncable.reMethodName.test(name)) {\n                this[name] = wrapCall(name);\n            } else {\n                console.warn('invalid rpc name:',name);\n            }\n        }\n\n        // add mixins\n        (own.mixins || []).forEach(function (mixin) {\n            for (var name in mixin) {\n                this[name] = mixin[name];\n            }\n        }, this);\n\n        // add other members\n        for (name in own) {\n            if (Syncable.reMethodName.test(name)) {\n                var memberType = own[name].constructor;\n                if (memberType === Function) { // non-op method\n                    // these must change state ONLY by invoking ops\n                    this[name] = own[name];\n                } else if (memberType===String || memberType===Number) {\n                    this[name] = own[name]; // some static constant, OK\n                } else if (name in Syncable.memberClasses) {\n                    // see above\n                    continue;\n                } else {\n                    console.warn('invalid member:',name,memberType);\n                }\n            } else {\n                console.warn('invalid member name:',name);\n            }\n        }\n\n        // add reactions\n        for (name in own.reactions || {}) {\n            var reaction = own.reactions[name];\n            if (!reaction) { continue; }\n\n            switch (typeof reaction) {\n            case 'function':\n                // handler-function\n                this._reactions[name] = [reaction];\n                break;\n            case 'string':\n                // handler-method name\n                this._reactions[name] = [this[name]];\n                break;\n            default:\n                if (reaction.constructor === Array) {\n                    // array of handlers\n                    this._reactions[name] = reaction.map(function (item) {\n                        switch (typeof item) {\n                        case 'function':\n                            return item;\n                        case 'string':\n                            return this[item];\n                        default:\n                            throw new Error('unexpected reaction type');\n                        }\n                    }, this);\n                } else {\n                    throw new Error('unexpected reaction type');\n                }\n            }\n        }\n\n        var syncProto = this;\n        this.callReactions = function (spec, value, src) {\n            var superReactions = syncProto._super.callReactions;\n            if ('function' === typeof superReactions) {\n                superReactions.call(this, spec, value, src);\n            }\n            var r = syncProto._reactions[spec.op()];\n            if (r) {\n                r.constructor !== Array && (r = [r]);\n                for (var i = 0; i < r.length; i++) {\n                    r[i] && r[i].call(this, spec, value, src);\n                }\n            }\n        };\n\n        this._super = parent.prototype;\n        this._type = fnid;\n    };\n\n    SyncProto.prototype = parent.prototype;\n    fn.prototype = new SyncProto();\n    fn._pt = fn.prototype; // just a shortcut\n\n    // default field values\n    var key;\n    var defs = fn.defaults = {};\n    for (key in (parent.defaults || {})) {\n        defs[key] = normalizeDefault(parent.defaults[key]);\n    }\n    for (key in (own.defaults || {})) {\n        defs[key] = normalizeDefault(own.defaults[key]);\n    }\n\n    function normalizeDefault(val) {\n        if (val && val.type) {\n            return val;\n        }\n        if (val && val.constructor === Function) {\n            return {type: val, value: undefined};\n        }\n        return {type:null, value: val};\n    }\n\n    // signature normalization for logged/remote/local method calls;\n    function wrapCall(name) {\n        return function wrapper() {\n            // assign a Lamport timestamp\n            var spec = this.newEventSpec(name);\n            var args = Array.prototype.slice.apply(arguments), lstn;\n            // find the callback if any\n            Syncable.isOpSink(args[args.length - 1]) && (lstn = args.pop());\n            // prettify the rest of the arguments\n            if (!args.length) {  // FIXME isn't it confusing?\n                args = ''; // used as 'empty'\n            } else if (args.length === 1) {\n                args = args[0]; // {key:val}\n            }\n            // TODO log 'initiated'\n            return this.deliver(spec, args, lstn);\n        };\n    }\n\n    // finishing touches\n    fn._super = parent;\n    fn.extend = this.extend;\n    fn.addReaction = this.addReaction;\n    fn.removeReaction = this.removeReaction;\n    Syncable.types[fnid] = fn;\n    return fn;\n};\n\n/**\n * A *reaction* is a hybrid of a listener and a method. It \"reacts\" on a\n * certain event for all objects of that type. The callback gets invoked\n * as a method, i.e. this===syncableObj. In an event-oriented architecture\n * reactions are rather handy, e.g. for creating mixins.\n * @param {string} op operation name\n * @param {function} fn callback\n * @returns {{op:string, fn:function}}\n */\nSyncable.addReaction = function (op, fn) {\n    var reactions = this.prototype._reactions;\n    var list = reactions[op];\n    list || (list = reactions[op] = []);\n    list.push(fn);\n    return {op: op, fn: fn};\n};\n\n/**\n *\n * @param handle\n */\nSyncable.removeReaction = function (handle) {\n    var op = handle.op,\n        fn = handle.fn,\n        list = this.prototype._reactions[op],\n        i = list.indexOf(fn);\n    if (i === -1) {\n        throw new Error('reaction unknown');\n    }\n    list[i] = undefined; // such a peculiar pattern not to mess up out-of-callback removal\n    while (list.length && !list[list.length - 1]) {\n        list.pop();\n    }\n};\n\n/**\n * compare two listeners\n * @param {{deliver:function, _src:*, sink:function}} ln listener from syncable._lstn\n * @param {function|{deliver:function}} other some other listener or function\n * @returns {boolean}\n */\nSyncable.listenerEquals = function (ln, other) {\n    return !!ln && ((ln === other) ||\n        (ln._src && ln._src === other) ||\n        (ln.fn && ln.fn === other) ||\n        (ln.sink && ln.sink === other));\n};\n\n// Syncable includes all the oplog, change propagation and distributed\n// garbage collection logix.\nSyncable.extend(Syncable, {  // :P\n    /**\n     * @returns {Spec} specifier \"/Type#objid\"\n     */\n    spec: function () { return new Spec('/' + this._type + '#' + this._id); },\n\n    /**\n     * Generates new specifier with unique version\n     * @param {string} op operation\n     * @returns {Spec}\n     */\n    newEventSpec: function (op) {\n        return this.spec().add(this._host.time(), '!').add(op, '.');\n    },\n\n    /**\n     * Returns current object state specifier\n     * @returns {string} specifier \"/Type#objid!version+source[!version+source2...]\"\n     */\n    stateSpec: function () {\n        return this.spec() + (this._version || ''); //?\n    },\n\n    /**\n     * Applies a serialized operation (or a batch thereof) to this replica\n     */\n    deliver: function (spec, value, lstn) {\n        spec = Spec.as(spec);\n        var opver = '!' + spec.version();\n        var error;\n\n        function fail(msg, ex) {\n            console.error(msg, spec, value, (ex && ex.stack) || ex || new Error(msg));\n            if (typeof(lstn) === 'function') {\n                lstn(spec.set('.fail'), msg);\n            } else if (lstn && typeof(lstn.error) === 'function') {\n                lstn.error(spec, msg);\n            } // else { } no callback provided\n        }\n\n        // sanity checks\n        if (spec.pattern() !== '/#!.') {\n            return fail('malformed spec', spec);\n        }\n        if (!this._id) {\n            return fail('undead object invoked');\n        }\n        if (error = this.validate(spec, value)) {\n            return fail('invalid input, ' + error, value);\n        }\n        if (!this.acl(spec, value, lstn)) {\n            return fail('access violation', spec);\n        }\n\n        env.debug && env.log(spec, value, lstn);\n\n        try {\n            var call = spec.op();\n            if (this._ops[call]) {  // FIXME name=>impl table\n                if (this.isReplay(spec)) { // it happens\n                    console.warn('replay', spec);\n                    return;\n                }\n                // invoke the implementation\n                this._ops[call].call(this, spec, value, lstn); // NOTE: no return value\n                // once applied, may remember in the log...\n                if (spec.op() !== 'init') {\n                    this._oplog && (this._oplog[spec.filter('!.')] = value);\n                    // this._version is practically a label that lets you know whether\n                    // the state has changed. Also, it allows to detect some cases of\n                    // concurrent change, as it is always set to the maximum version id\n                    // received by this object. Still, only the full version vector may\n                    // precisely and uniquely specify the current version (see version()).\n                    this._version = (opver > this._version) ? opver : this._version + opver;\n                } else {\n                    value = this.diff('!0');\n                }\n                // ...and relay further to downstream replicas and various listeners\n                this.emit(spec, value, lstn);\n            } else if (this._neutrals[call]) {\n                // invoke the implementation\n                this._neutrals[call].call(this, spec, value, lstn);\n                // and relay to listeners\n                this.emit(spec, value, lstn);\n            } else {\n                this.unimplemented(spec, value, lstn);\n            }\n        } catch (ex) { // log and rethrow; don't relay further; don't log\n            return fail(\"method execution failed\", ex);\n        }\n\n        // to force async signatures we eat the returned value silently\n        return spec;\n    },\n\n    /**\n     * Notify all the listeners of a state change (i.e. the operation applied).\n     */\n    emit: function (spec, value, src) {\n        var ls = this._lstn,\n            op = spec.op(),\n            is_neutrals = op in this._neutrals;\n        if (ls) {\n            var notify = [];\n            for (var i = 0; i < ls.length; i++) {\n                var l = ls[i];\n                // skip empties, deferreds and the source\n                if (!l || l === ',' || l === src) { continue; }\n                if (is_neutrals && l._op !== op) { continue; }\n                if (l._op && l._op !== op) { continue; }\n                notify.push(l);\n            }\n            for (i = 0; i < notify.length; i++) { // screw it I want my 'this'\n                try {\n                    notify[i].deliver(spec, value, this);\n                } catch (ex) {\n                    console.error(ex.message, ex.stack);\n                }\n            }\n        }\n        this.callReactions(spec, value, src);\n    },\n\n    trigger: function (event, params) {\n        var spec = this.newEventSpec(event);\n        this.deliver(spec, params);\n    },\n\n    /**\n     * Blindly applies a JSON changeset to this model.\n     * @param {*} values\n     */\n    apply: function (values) {\n        for (var key in values) {\n            if (Syncable.reFieldName.test(key)) { // skip special fields\n                var def = this.constructor.defaults[key];\n                this[key] = def && def.type ?\n                    new def.type(values[key]) : values[key];\n            }\n        }\n    },\n\n    /**\n     * @returns {Spec.Map} the version vector for this object\n     */\n    version: function () {\n        // distillLog() may drop some operations; still, those need to be counted\n        // in the version vector; so, their Lamport ids must be saved in this._vector\n        var map = new Spec.Map(this._version + (this._vector || ''));\n        if (this._oplog) {\n            for (var op in this._oplog) {\n                map.add(op);\n            }\n        }\n        return map; // TODO return the object, let the consumer trim it to taste\n    },\n\n    /**\n     * Produce the entire state or probably the necessary difference\n     * to synchronize a replica which is at version *base*.\n     * The format of a state/patch object is:\n     * {\n     *   // A version label, see Syncable(). Presence of the label means\n     *   // that this object has a snapshot of the state. No version\n     *   // means it is a diff (log tail).\n     *   _version: Spec,\n     *   // Some parts of the version vector that can not be derived from\n     *   // _oplog or _version.\n     *   _vector: Spec,\n     *   // Some ops that were already applied. See distillLog()\n     *   _oplog: { spec: value },\n     *   // Pending ops that need to be applied.\n     *   _tail: { spec: value }\n     * }\n     *\n     * The state object must survive JSON.parse(JSON.stringify(obj))\n     *\n     * In many cases, the size of a distilled log is small enough to\n     * use it for state transfer (i.e. no snapshots needed).\n     */\n    diff: function (base) {\n        //var vid = new Spec(this._version).get('!'); // first !token\n        //var spec = vid + '.patch';\n        if (!this._version) { return undefined; }\n        this.distillLog(); // TODO optimize?\n        var patch, spec;\n        if (base && base != '!0' && base != '0') { // FIXME ugly\n            var map = new Spec.Map(base || '');\n            for (spec in this._oplog) {\n                if (!map.covers(new Spec(spec).version())) {\n                    patch = patch || {_tail: {}}; // NOTE: no _version\n                    patch._tail[spec] = this._oplog[spec];\n                }\n            }\n        } else {\n            patch = {_version: '!0', _tail: {}}; // zero state plus the tail\n            for (spec in this._oplog) {\n                patch._tail[spec] = this._oplog[spec];\n            }\n        }\n        return patch;\n    },\n\n    distillLog: function () {\n    },\n\n    /**\n     * The method must decide whether the source of the operation has\n     * the rights to perform it. The method may check both the nearest\n     * source and the original author of the op.\n     * If this method ever mentions 'this', that is a really bad sign.\n     * @returns {boolean}\n     */\n    acl: function (spec, val, src) {\n        return true;\n    },\n\n    /**\n     * Check operation format/validity (recommendation: don't check against the current state)\n     * @returns {string} '' if OK, error message otherwise.\n     */\n    validate: function (spec, val, src) {\n        if (spec.pattern() !== '/#!.') {\n            return 'incomplete event spec';\n        }\n        if (this.clock && spec.type()!=='Host' && !this.clock.checkTimestamp(spec.version())) {\n            return 'invalid timestamp '+spec;\n        }\n    },\n\n    /**\n     * whether this op was already applied in the past\n     * @returns {boolean}\n     */\n    isReplay: function (spec) {\n        if (!this._version) { return false; }\n        if (spec.op() === 'init') { return false; } // these are .on !vids\n        var opver = spec.version();\n        if (opver > this._version.substr(1)) { return false; }\n        if (spec.filter('!.').toString() in this._oplog) { return true; }// TODO log trimming, vvectors?\n        return this.version().covers(opver); // heavyweight\n    },\n\n    /**\n     * External objects (those you create by supplying an id) need first to query\n     * the uplink for their state. Before the state arrives they are stateless.\n     * @return {boolean}\n     */\n    hasState: function () {\n        return !!this._version;\n    },\n\n    getListenerIndex: function (search_for, uplinks_only) {\n        var i = this._lstn.indexOf(search_for),\n            l;\n        if (i > -1) { return i; }\n\n        for (i = 0, l = this._lstn.length; i < l; i++) {\n            var ln = this._lstn[i];\n            if (uplinks_only && ln === ',') {\n                return -1;\n            }\n            if (Syncable.listenerEquals(ln, search_for)) {\n                return i;\n            }\n        }\n        return -1;\n    },\n\n    reset: function () {\n        var defs = this.constructor.defaults;\n        for (var name in defs) {\n            var def = defs[name];\n            if (def.type) {\n                this[name] = def.value ? new def.type(def.value) : new def.type();\n            } else {\n                this[name] = def.value;\n            }\n        }\n    },\n\n\n    neutrals: {\n        /**\n         * Subscribe to the object's operations;\n         * the upstream part of the two-way subscription\n         *  on() with a full filter:\n         *  @param {Spec} spec /Mouse#Mickey!now.on\n         *  @param {Spec|string} filter !since.event\n         *  @param {{deliver:function}|function} repl callback\n         *  @this {Syncable}\n         *\n         * TODO: prevent second subscription\n         */\n        on: function (spec, filter, repl) {   // WELL  on() is not an op, right?\n            // if no listener is supplied then the object is only\n            // guaranteed to exist till the next Host.gc() run\n            if (!repl) { return; }\n\n            var self = this;\n            // stateless objects fire no events; essentially, on() is deferred\n            if (!this._version && filter) { // TODO solidify\n                this._lstn.push({\n                    _op: 'reon',\n                    _src: repl,\n                    deliver: function () {\n                        var i = self._lstn.indexOf(this);\n                        self._lstn.splice(i, 1);\n                        self.deliver(spec, filter, repl);\n                    }\n                });\n                return; // defer this call till uplinks are ready\n            }\n            // make all listeners uniform objects\n            if (repl.constructor === Function) {\n                repl = {\n                    sink: repl,\n                    that: this,\n                    deliver: function () { // .deliver is invoked on an event\n                        this.sink.apply(this.that, arguments);\n                    }\n                };\n            }\n\n            if (filter) {\n                filter = new Spec(filter, '.');\n                var baseVersion = filter.filter('!'),\n                    filter_by_op = filter.get('.');\n\n                if (filter_by_op === 'init') {\n                    var diff_if_needed = baseVersion ? this.diff(baseVersion) : '';\n                    repl.deliver(spec.set('.init'), diff_if_needed, this); //??\n                    // FIXME use once()\n                    return;\n                }\n                if (filter_by_op) {\n                    repl = {\n                        sink: repl,\n                        _op: filter_by_op,\n                        deliver: function deliverWithFilter(spec, val, src) {\n                            if (spec.op() === filter_by_op) {\n                                this.sink.deliver(spec, val, src);\n                            }\n                        }\n                    };\n                }\n\n                if (!baseVersion.isEmpty()) {\n                    var diff = this.diff(baseVersion);\n                    diff && repl.deliver(spec.set('.init'), diff, this); // 2downlink\n                    repl.deliver(spec.set('.reon'), this.version().toString(), this);\n                }\n            }\n\n            this._lstn.push(repl);\n            // TODO repeated subscriptions: send a diff, otherwise ignore\n        },\n\n        /**\n         * downstream reciprocal subscription\n         */\n        reon: function (spec, filter, repl) {\n            if (filter) {  // a diff is requested\n                var base = Spec.as(filter).tok('!');\n                var diff = this.diff(base);\n                if (diff) {\n                    repl.deliver(spec.set('.init'), diff, this);\n                }\n            }\n        },\n\n        /** Unsubscribe */\n        off: function (spec, val, repl) {\n            var idx = this.getListenerIndex(repl); //TODO ??? uplinks_only?\n            if (idx > -1) {\n                this._lstn.splice(idx, 1);\n            }\n        },\n\n        /** Reciprocal unsubscription */\n        reoff: function (spec, val, repl) {\n            var idx = this.getListenerIndex(repl); //TODO ??? uplinks_only?\n            if (idx > -1) {\n                this._lstn.splice(idx, 1);\n            }\n            if (this._id) {\n                this.checkUplink();\n            }\n        },\n\n        /**\n         * As all the event/operation processing is asynchronous, we\n         * cannot simply throw/catch exceptions over the network.\n         * This method allows to send errors back asynchronously.\n         * Sort of an asynchronous complaint mailbox :)\n         */\n        error: function (spec, val, repl) {\n            console.error('something failed:', spec, val, '@', (repl && repl._id));\n        }\n\n    }, // neutrals\n\n    ops: {\n        /**\n         * A state of a Syncable CRDT object is transferred to a replica using\n         * some combination of POJO state and oplog. For example, a simple LWW\n         * object (Last Writer Wins, see Model.js) uses its distilled oplog\n         * as the most concise form. A CT document (Causal Trees) has a highly\n         * compressed state, its log being hundred times heavier. Hence, it\n         * mainly uses its plain state, but sometimes its log tail as well. The\n         * format of the state object is POJO plus (optionally) special fields:\n         * _oplog, _tail, _vector, _version (the latter flags POJO presence).\n         * In either case, .init is only produced by diff() (+ by storage).\n         * Any real-time changes are transferred as individual events.\n         * @this {Syncable}\n         */\n        init: function (spec, state, src) {\n\n            var tail = {}, // ops to be applied on top of the received state\n                typeid = spec.filter('/#'),\n                lstn = this._lstn,\n                a_spec;\n            this._lstn = []; // prevent events from being fired\n\n            if (state._version/* && state._version !== '!0'*/) {\n                // local changes may need to be merged into the received state\n                if (this._oplog) {\n                    for (a_spec in this._oplog) {\n                        tail[a_spec] = this._oplog[a_spec];\n                    }\n                    this._oplog = {};\n                }\n                this._vector && (this._vector = undefined);\n                // zero everything\n                for (var key in this) {\n                    if (this.hasOwnProperty(key) && key.charAt(0) !== '_') {\n                        this[key] = undefined;\n                    }\n                }\n                // set default values\n                this.reset();\n\n                this.apply(state);\n                this._version = state._version;\n\n                state._oplog && (this._oplog = state._oplog); // FIXME copy\n                state._vector && (this._vector = state._vector);\n            }\n            // add the received tail to the local one\n            if (state._tail) {\n                for (a_spec in state._tail) {\n                    tail[a_spec] = state._tail[a_spec];\n                }\n            }\n            // appply the combined tail to the new state\n            var specs = [];\n            for (a_spec in tail) {\n                specs.push(a_spec);\n            }\n            specs.sort().reverse();\n            // there will be some replays, but those will be ignored\n            while (a_spec = specs.pop()) {\n                this.deliver(typeid.add(a_spec), tail[a_spec], this);\n            }\n\n            this._lstn = lstn;\n\n        }\n\n    }, // ops\n\n\n    /**\n     * Uplink connections may be closed or reestablished so we need\n     * to adjust every object's subscriptions time to time.\n     * @this {Syncable}\n     */\n    checkUplink: function () {\n        var new_uplinks = this._host.getSources(this.spec()).slice(),\n            up, self = this;\n        // the plan is to eliminate extra subscriptions and to\n        // establish missing ones; that only affects outbound subs\n        for (var i = 0; i < this._lstn.length && this._lstn[i] != ','; i++) {\n            up = this._lstn[i];\n            if (!up) {\n                continue;\n            }\n            up._src && (up = up._src); // unready\n            var up_idx = new_uplinks.indexOf(up);\n            if (up_idx === -1) { // don't need this uplink anymore\n                up.deliver(this.newEventSpec('off'), '', this);\n            } else {\n                new_uplinks[up_idx] = undefined;\n            }\n        }\n        // subscribe to the new\n        for (i = 0; i < new_uplinks.length; i++) {\n            up = new_uplinks[i];\n            if (!up) {\n                continue;\n            }\n            var onspec = this.newEventSpec('on');\n            this._lstn.unshift({\n                _op: 'reon',\n                _src: up,\n                deliver: function (spec, base, src) {\n                    if (spec.version() !== onspec.version()) {\n                        return;\n                    } // not mine\n\n                    var i = self.getListenerIndex(this);\n                    self._lstn[i] = up;\n                }\n            });\n            up.deliver(onspec, this.version().toString(), this);\n        }\n    },\n\n    /**\n     * returns a Plain Javascript Object with the state\n     * @this {Syncable}\n     */\n    pojo: function (addVersionInfo) {\n        var pojo = {},\n            defs = this.constructor.defaults;\n        for (var key in this) {\n            if (this.hasOwnProperty(key)) {\n                if (Syncable.reFieldName.test(key) && this[key] !== undefined) {\n                    var def = defs[key],\n                        val = this[key];\n                    pojo[key] = def && def.type ?\n                    (val.toJSON && val.toJSON()) || val.toString() :\n                            (val && val._id ? val._id : val); // TODO prettify\n                }\n            }\n        }\n        if (addVersionInfo) {\n            pojo._id = this._id; // not necassary\n            pojo._version = this._version;\n            this._vector && (pojo._vector = this._vector);\n            this._oplog && (pojo._oplog = this._oplog); //TODO copy\n        }\n        return pojo;\n    },\n\n    /**\n     * Sometimes we get an operation we don't support; not normally\n     * happens for a regular replica, but still needs to be caught\n     */\n    unimplemented: function (spec, val, repl) {\n        console.warn(\"method not implemented:\", spec);\n    },\n\n    /**\n     * Deallocate everything, free all resources.\n     */\n    close: function () {\n        var l = this._lstn,\n            s = this.spec(),\n            uplink;\n\n        this._id = null; // no id - no object; prevent relinking\n        while ((uplink = l.shift()) && uplink !== ',') {\n            uplink.off(s, null, this);\n        }\n        while (l.length) {\n            l.pop().deliver(s.set('.reoff'), null, this);\n        }\n        this._host.unregister(this);\n    },\n\n    /**\n     * Once an object is not listened by anyone it is perfectly safe\n     * to garbage collect it.\n     */\n    gc: function () {\n        var l = this._lstn;\n        if (!l.length || (l.length === 1 && !l[0])) {\n            this.close();\n        }\n    },\n\n    /**\n     * @param {string} filter event filter for subscription\n     * @param {function} cb callback (will be called once)\n     * @see Syncable#on\n     */\n    once: function (filter, cb) {\n        this.on(filter, function onceWrap(spec, val, src) {\n            // \"this\" is the object (Syncable)\n            if (cb.constructor === Function) {\n                cb.call(this, spec, val, src);\n            } else {\n                cb.deliver(spec, val, src);\n            }\n            this.off(filter, onceWrap);\n        });\n    }\n});\n\n\nSyncable.reFieldName = /^[a-z][a-z0-9]*([A-Z][a-z0-9]*)*$/;\n\n/**\n * Derive version vector from a state of a Syncable object.\n * This is not a method as it needs to be applied to a flat JSON object.\n * @see Syncable.version\n * @see Spec.Map\n * @returns {string} string representation of Spec.Map\n */\nSyncable.stateVersionVector = function stateVersionVector(state) {\n    var op,\n        map = new Spec.Map( (state._version||'!0') + (state._vector || '') );\n    if (state._oplog) {\n        for (op in state._oplog) {\n            map.add(op);\n        }\n    }\n    if (state._tail) {\n        for (op in state._tail) {\n            map.add(op);\n        }\n    }\n    return map.toString();\n};\n","/home/travis/build/npmtest/node-npmtest-swarm/node_modules/swarm/lib/Model.js":"\"use strict\";\n\nvar Spec = require('./Spec');\nvar Syncable = require('./Syncable');\n\n/**\n * Model (LWW key-value object)\n * @param idOrState\n * @constructor\n */\nfunction Model(idOrState) {\n    var ret = Model._super.apply(this, arguments);\n    /// TODO: combine with state push, make clean\n    if (ret === this && idOrState && idOrState.constructor !== String && !Spec.is(idOrState)) {\n        this.deliver(this.spec().add(this._id, '!').add('.set'), idOrState);\n    }\n}\n\nmodule.exports = Syncable.extend(Model, {\n    defaults: {\n        _oplog: Object\n    },\n    /**  init modes:\n     *    1  fresh id, fresh object\n     *    2  known id, stateless object\n     *    3  known id, state boot\n     */\n    neutrals: {\n        on: function (spec, base, repl) {\n            //  support the model.on('field',callback_fn) pattern\n            if (typeof(repl) === 'function' &&\n                    typeof(base) === 'string' &&\n                    (base in this.constructor.defaults)) {\n                var stub = {\n                    fn: repl,\n                    key: base,\n                    self: this,\n                    _op: 'set',\n                    deliver: function (spec, val, src) {\n                        if (this.key in val) {\n                            this.fn.call(this.self, spec, val, src);\n                        }\n                    }\n                };\n                repl = stub;\n                base = '';\n            }\n            // this will delay response if we have no state yet\n            Syncable._pt._neutrals.on.call(this, spec, base, repl);\n        },\n\n        off: function (spec, base, repl) {\n            var ls = this._lstn;\n            if (typeof(repl) === 'function') { // TODO ugly\n                for (var i = 0; i < ls.length; i++) {\n                    if (ls[i] && ls[i].fn === repl && ls[i].key === base) {\n                        repl = ls[i];\n                        break;\n                    }\n                }\n            }\n            Syncable._pt._neutrals.off.apply(this, arguments);\n        }\n\n    },\n\n    // TODO remove unnecessary value duplication\n    packState: function (state) {\n    },\n    unpackState: function (state) {\n    },\n    /**\n     * Removes redundant information from the log; as we carry a copy\n     * of the log in every replica we do everythin to obtain the minimal\n     * necessary subset of it.\n     * As a side effect, distillLog allows up to handle some partial\n     * order issues (see _ops.set).\n     * @see Model.ops.set\n     * @returns {*} distilled log {spec:true}\n     */\n    distillLog: function () {\n        // explain\n        var sets = [],\n            cumul = {},\n            heads = {},\n            spec;\n        for (var s in this._oplog) {\n            spec = new Spec(s);\n            //if (spec.op() === 'set') {\n            sets.push(spec);\n            //}\n        }\n        sets.sort();\n        for (var i = sets.length - 1; i >= 0; i--) {\n            spec = sets[i];\n            var val = this._oplog[spec],\n                notempty = false;\n            for (var field in val) {\n                if (field in cumul) {\n                    delete val[field];\n                } else {\n                    notempty = cumul[field] = val[field]; //store last value of the field\n                }\n            }\n            var source = spec.source();\n            notempty || (heads[source] && delete this._oplog[spec]);\n            heads[source] = true;\n        }\n        return cumul;\n    },\n\n    ops: {\n        /**\n         * This barebones Model class implements just one kind of an op:\n         * set({key:value}). To implment your own ops you need to understand\n         * implications of partial order as ops may be applied in slightly\n         * different orders at different replicas. This implementation\n         * may resort to distillLog() to linearize ops.\n         */\n        set: function (spec, value, repl) {\n            var version = spec.version(),\n                vermet = spec.filter('!.').toString();\n            if (version < this._version.substr(1)) {\n                this._oplog[vermet] = value;\n                this.distillLog(); // may amend the value\n                value = this._oplog[vermet];\n            }\n            value && this.apply(value);\n        }\n    },\n\n    fill: function (key) { // TODO goes to Model to support references\n        if (!this.hasOwnProperty(key)) {\n            throw new Error('no such entry');\n        }\n\n        //if (!Spec.is(this[key]))\n        //    throw new Error('not a specifier');\n        var spec = new Spec(this[key]).filter('/#');\n        if (spec.pattern() !== '/#') {\n            throw new Error('incomplete spec');\n        }\n\n        this[key] = this._host.get(spec);\n        /* TODO new this.refType(id) || new Swarm.types[type](id);\n         on('init', function(){\n         self.emit('fill',key,this)\n         self.emit('full',key,this)\n         });*/\n    },\n\n    /**\n     * Generate .set operation after some of the model fields were changed\n     * TODO write test for Model.save()\n     */\n    save: function () {\n        var cumul = this.distillLog(),\n            changes = {},\n            pojo = this.pojo(),\n            field;\n        for (field in pojo) {\n            if (this[field] !== cumul[field]) {// TODO nesteds\n                changes[field] = this[field];\n            }\n        }\n        for (field in cumul) {\n            if (!(field in pojo)) {\n                changes[field] = null; // JSON has no undefined\n            }\n        }\n        this.set(changes);\n    },\n\n    validate: function (spec, val) {\n        if (spec.op() !== 'set') {\n            return '';\n        } // no idea\n        for (var key in val) {\n            if (!Syncable.reFieldName.test(key)) {\n                return 'bad field name';\n            }\n        }\n        return '';\n    }\n\n});\n\n// Model may have reactions for field changes as well as for 'real' ops/events\n// (a field change is a .set operation accepting a {field:newValue} map)\nmodule.exports.addReaction = function (methodOrField, fn) {\n    var proto = this.prototype;\n    if (typeof (proto[methodOrField]) === 'function') { // it is a field name\n        return Syncable.addReaction.call(this, methodOrField, fn);\n    } else {\n        var wrapper = function (spec, val) {\n            if (methodOrField in val) {\n                fn.apply(this, arguments);\n            }\n        };\n        wrapper._rwrap = true;\n        return Syncable.addReaction.call(this, 'set', wrapper);\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-swarm/node_modules/swarm/lib/Set.js":"\"use strict\";\n\nvar env = require('./env');\nvar Spec = require('./Spec');\nvar Syncable = require('./Syncable');\nvar Model = require('./Model'); // TODO\nvar ProxyListener = require('./ProxyListener');\nvar CollectionMethodsMixin = require('./CollectionMethodsMixin');\n\n/**\n * Backbone's Collection is essentially an array and arrays behave poorly\n * under concurrent writes (see OT). Hence, our primary collection type\n * is a {id:Model} Set. One may obtain a linearized version by sorting\n * them by keys or otherwise.\n * This basic Set implementation can only store objects of the same type.\n * @constructor\n */\nmodule.exports = Syncable.extend('Set', {\n\n    defaults: {\n        _objects: Object,\n        _oplog: Object,\n        _proxy: ProxyListener\n    },\n\n    mixins: [\n        CollectionMethodsMixin\n    ],\n\n    reactions: {\n        init: function (spec,val,src) {\n            this.forEach(function (obj) {\n                obj.on(this._proxy);\n            }, this);\n        }\n    },\n\n    ops: {\n        /**\n         * Both Model and Set are oplog-only; they never pass the state on the wire,\n         * only the oplog; new replicas are booted with distilled oplog as well.\n         * So, this is the only point in the code that mutates the state of a Set.\n         */\n        change: function (spec, value, repl) {\n            value = this.distillOp(spec, value);\n            var key_spec;\n            for (key_spec in value) {\n                if (value[key_spec] === 1) {\n                    if (!this._objects[key_spec]) { // only if object not in the set\n                        this._objects[key_spec] = this._host.get(key_spec);\n                        this._objects[key_spec].on(this._proxy);\n                    }\n                } else if (value[key_spec] === 0) {\n                    if (this._objects[key_spec]) {\n                        this._objects[key_spec].off(this._proxy);\n                        delete this._objects[key_spec];\n                    }\n                } else {\n                    env.log(this.spec(), 'unexpected val', JSON.stringify(value));\n                }\n            }\n        }\n    },\n\n    validate: function (spec, val, src) {\n        if (spec.op() !== 'change') {\n            return '';\n        }\n\n        for (var key_spec in val) {\n            // member spec validity\n            if (Spec.pattern(key_spec) !== '/#') {\n                return 'invalid spec: ' + key_spec;\n            }\n        }\n        return '';\n    },\n\n    distillOp: function (spec, val) {\n        if (spec.version() > this._version) {\n            return val; // no concurrent op\n        }\n        var opkey = spec.filter('!.');\n        this._oplog[opkey] = val;\n        this.distillLog(); // may amend the value\n        return this._oplog[opkey] || {};\n    },\n\n    distillLog: Model.prototype.distillLog,\n\n    pojo: function () {\n        // invoke super.pojo()\n        var result = Syncable._pt.pojo.apply(this, arguments);\n        result.entries = Object.keys(this._objects);\n        return result;\n    },\n\n    /**\n     * Adds an object to the set.\n     * @param {Syncable} obj the object  //TODO , its id or its specifier.\n     */\n    addObject: function (obj) {\n        var specs = {};\n        specs[obj.spec()] = 1;\n        this.change(specs);\n    },\n    // FIXME reactions to emit .add, .remove\n\n    removeObject: function (obj) {\n        var spec = obj._id ? obj.spec() : new Spec(obj).filter('/#');\n        if (spec.pattern() !== '/#') {\n            throw new Error('invalid spec: ' + spec);\n        }\n        var specs = {};\n        specs[spec] = 0;\n        this.change(specs);\n    },\n\n    /**\n     * @param {Spec|string} key_spec key (specifier)\n     * @returns {Syncable} object by key\n     */\n    get: function (key_spec) {\n        key_spec = new Spec(key_spec).filter('/#');\n        if (key_spec.pattern() !== '/#') {\n            throw new Error(\"invalid spec\");\n        }\n        return this._objects[key_spec];\n    },\n\n    /**\n     * @param {function?} order\n     * @returns {Array} sorted list of objects currently in set\n     */\n    list: function (order) {\n        var ret = [];\n        for (var key in this._objects) {\n            ret.push(this._objects[key]);\n        }\n        ret.sort(order);\n        return ret;\n    },\n\n    forEach: function (cb, thisArg) {\n        var index = 0;\n        for (var spec in this._objects) {\n            cb.call(thisArg, this._objects[spec], index++);\n        }\n    },\n\n    every: function (cb, thisArg) {\n        var index = 0;\n        for (var spec in this._objects) {\n            if (!cb.call(thisArg, this._objects[spec], index++)) {\n                return false;\n            }\n        }\n        return true;\n    },\n\n    filter: function (cb, thisArg) {\n        var res = [];\n        this.forEach(function (entry, idx) {\n            if (cb.call(thisArg, entry, idx)) {\n                res.push(entry);\n            }\n        });\n        return res;\n    },\n\n    map: function (cb, thisArg) {\n        var res = [];\n        this.forEach(function (entry, idx) {\n            res.push(cb.call(thisArg, entry, idx));\n        });\n        return res;\n    }\n});\n","/home/travis/build/npmtest/node-npmtest-swarm/node_modules/swarm/lib/ProxyListener.js":"\"use strict\";\n\nfunction ProxyListener() {\n    this.callbacks = null;\n    this.owner = null;\n}\n\nProxyListener.prototype.deliver = function (spec,value,src) {\n    if (this.callbacks===null) { return; }\n    var that = this.owner || src;\n    for(var i=0; i<this.callbacks.length; i++) {\n        var cb = this.callbacks[i];\n        if (cb.constructor===Function) {\n            cb.call(that,spec,value,src);\n        } else {\n            cb.deliver(spec,value,src);\n        }\n    }\n};\n\nProxyListener.prototype.on = function (callback) {\n    if (this.callbacks===null) { this.callbacks = []; }\n    this.callbacks.push(callback);\n};\n\nProxyListener.prototype.off = function (callback) {\n    if (this.callbacks===null) { return; }\n    var i = this.callbacks.indexOf(callback);\n    if (i!==-1) {\n        this.callbacks.splice(i,1);\n    } else {\n        console.warn('listener unknown', callback);\n    }\n};\n\nmodule.exports = ProxyListener;\n","/home/travis/build/npmtest/node-npmtest-swarm/node_modules/swarm/lib/CollectionMethodsMixin.js":"\"use strict\";\n\n\nmodule.exports = {\n\n    /**\n     * Subscribe on collections entries' events\n     * @param {function(Spec|string, Object, {deliver: function()})} callback\n     * @this Set|Vector\n     */\n    onObjectEvent: function (callback) {\n        this._proxy.owner = this;\n        this._proxy.on(callback);\n    },\n\n    /**\n     * Unsubscribe from collections entries' events\n     * @param {function(*)} callback\n     * @this Set|Vector\n     */\n    offObjectEvent: function (callback) {\n        this._proxy.off(callback);\n    },\n\n    /**\n     * Waits for collection to receive state from cache or uplink and then invokes passed callback\n     *\n     * @param {function()} callback\n     * @this Set|Vector\n     */\n    onObjectStateReady: function (callback) { // TODO timeout ?\n        var self = this;\n        function checker() {\n            var notInitedYet = self.filter(function (entry) {\n                return !entry._version;\n            });\n            if (!notInitedYet.length) {\n                // all entries are inited\n                callback();\n            } else {\n                // wait for some entry not ready yet\n                var randomIdx = (Math.random() * (notInitedYet.length - 1)) | 0;\n                notInitedYet[randomIdx].once('init', checker);\n            }\n        }\n        if (this._version) {\n            checker();\n        } else {\n            this.once('init', checker);\n        }\n    }\n};","/home/travis/build/npmtest/node-npmtest-swarm/node_modules/swarm/lib/Vector.js":"\"use strict\";\n\nvar Spec = require('./Spec');\nvar LongSpec = require('./LongSpec');\nvar Syncable = require('./Syncable');\nvar ProxyListener = require('./ProxyListener');\nvar CollectionMethodsMixin = require('./CollectionMethodsMixin');\n\n/** In distributed environments, linear structures are tricky. It is always\n *  recommended to use (sorted) Set as your default collection type. Still, in\n *  some cases we need precisely a Vector, so here it is. Note that a vector can\n *  not prune its mutation history for quite a while, so it is better not to\n *  sort (reorder) it repeatedly. The perfect usage pattern is a growing vector+\n *  insert sort or no sort at all. If you need to re-shuffle a vector\n *  differently or replace its contents, you'd better create a new vector.\n *  So, you've been warned.\n *  Vector is implemented on top of a LongSpec, so the API is very much alike.\n *  The replication/convergence/correctness algorithm is Causal Trees.\n *\n *  TODO support JSON types (as a part of ref-gen-refac)\n */\nmodule.exports = Syncable.extend('Vector', {\n\n    defaults: {\n        _oplog: Object,\n        _objects: Array,\n        _order: LongSpec,\n        _proxy: ProxyListener\n    },\n\n    mixins: [\n        CollectionMethodsMixin\n    ],\n\n    ops: {  // operations is our assembly language\n\n        // insert an object\n        in: function (spec, value, src) {\n            // we misuse specifiers to express the operation in\n            // a compact non-ambiguous way\n            value = new Spec(value);\n            var opid = spec.tok('!');\n            var at = value.tok('!');\n            if (opid<=at) {\n                throw new Error('timestamps are messed up');\n            }\n            var what = value.tok('#');\n            if (!what) { throw new Error('object #id not specified'); }\n            var type = value.get('/');\n            if (!type && this.objectType) {\n                type = this.objectType.prototype._type;\n            }\n            if (!type) {\n                throw new Error('object /type not specified');\n            }\n            type = '/' + type;\n\n            var pos = this.findPositionFor(opid, at?at:'!0');\n            var obj = this._host.get(type+what);\n\n            this._objects.splice(pos.index,0,obj);\n            this._order.insert(opid,pos);\n\n            obj.on(this._proxy);\n        },\n\n        // remove an object\n        rm: function (spec, value, src) {\n            value = Spec.as(value);\n            var target = value.tok('!');\n            var hint = value.has('.') ? Spec.base2int(value.get('.')) : 0;\n            var at = this._order.find(target, Math.max(0,hint-5));\n            if (at.end()) {\n                at = this._order.find(target, 0);\n            }\n            if (at.end()) {\n                // this can only be explained by concurrent deletion\n                // partial order can't break cause-and-effect ordering\n                return;\n            }\n            var obj = this._objects[at.index];\n            this._objects.splice(at.index,1);\n            at.erase(1);\n\n            obj.off(this._proxy);\n        }\n\n        /** Either thombstones or log  before HORIZON\n        patch: function (spec, value, src) {\n\n        }*/\n\n    },\n\n    distillLog: function () {\n        // TODO HORIZON\n    },\n\n    reactions: {\n\n        'init': function fillAll (spec,val,src) { // TODO: reactions, state init tests\n            for(var i=this._order.iterator(); !i.end(); i.next()) {\n                var op = i.token() + '.in';\n                var value = this._oplog[op];\n                var obj = this.getObject(value);\n                this._objects[i.index] = obj;\n                obj.on(this._proxy);\n            }\n        }\n\n    },\n\n    pojo: function () {\n        // invoke super.pojo()\n        var result = Syncable._pt.pojo.apply(this, arguments);\n        result.entries = Object.keys(this._objects);\n        return result;\n    },\n\n    getObject: function (spec) {\n        spec = new Spec(spec,'#');\n        if (!spec.has('/')) {\n            if (this.objectType) {\n                spec = spec.add(this.objectType.prototype._type,'/').sort();\n            } else {\n                throw new Error(\"type not specified\"); // TODO is it necessary at all?\n            }\n        }\n        var obj = this._host.get(spec);\n        return obj;\n    },\n\n    length: function () {\n        return this._objects.length;\n    },\n\n    //  C A U S A L  T R E E S  M A G I C\n\n    findPositionFor: function (id, parentId) { // FIXME protected methods && statics (entryType)\n        if (!parentId) {\n            parentId = this.getParentOf(id);\n        }\n        var next;\n        if (parentId!=='!0') {\n            next = this._order.find(parentId);\n            if (next.end()) {\n                next = this.findPositionFor(parentId);\n            }\n            next.next();\n        } else {\n            next = this._order.iterator();\n        }\n        // skip \"younger\" concurrent siblings\n        while (!next.end()) {\n            var nextId = next.token();\n            if (nextId<id) {\n                break;\n            }\n            var subtreeId = this.inSubtreeOf(nextId,parentId);\n            if (!subtreeId || subtreeId<id) {\n                break;\n            }\n            this.skipSubtree(next,subtreeId);\n        }\n        return next; // insert before\n    },\n\n    getParentOf: function (id) {\n        var spec = this._oplog[id+'.in'];\n        if (!spec) {\n            throw new Error('operation unknown: '+id);\n        }\n        var parentId = Spec.as(spec).tok('!') || '!0';\n        return parentId;\n    },\n\n    /** returns the immediate child of the root node that is an ancestor\n      * of the given node. */\n    inSubtreeOf: function (nodeId, rootId) {\n        var id=nodeId, p=id;\n        while (id>rootId) {\n            p=id;\n            id=this.getParentOf(id);\n        }\n        return id===rootId && p;\n    },\n\n    isDescendantOf: function (nodeId, rootId) {\n        var i=nodeId;\n        while (i>rootId) {\n            i=this.getParentOf(i);\n        }\n        return i===rootId;\n    },\n\n    skipSubtree: function (iter, root) {\n        root = root || iter.token();\n        do {\n            iter.next();\n        } while (!iter.end() && this.isDescendantOf(iter.token(),root));\n        return iter;\n    },\n\n    validate: function (spec, val, source) {\n        // ref op is known\n    },\n\n    //  A R R A Y - L I K E  A P I\n    //  wrapper methods that convert into op calls above\n\n    indexOf: function (obj, startAt) {\n        if (!obj._id) {\n            obj = this.getObject(obj);\n        }\n        return this._objects.indexOf(obj,startAt);\n    },\n\n    /*splice: function (offset, removeCount, insert) {\n        var ref = offset===-1 ? '' : this._objects[offset];\n        var del = [];\n        var hint;\n        for (var rm=1; rm<=removeCount; rm++) {\n            del.push(this._order.entryAt(offset+rm));\n        }\n        for(var a=3; a<this.arguments.length; a++) {\n            var arg = this.arguments[a];\n            arg = _id in arg ? arg._id : arg;\n            if (!Spec.isId(arg)) { throw new Error('malformed id: '+arg); }\n            ins.push(arg);\n        }\n        while (rmid=del.pop()) {\n            this.del(rmid+hint);\n        }\n        while (insid=ins.pop()) {\n            this.ins(ref+insid+hint);\n        }\n    },*/\n\n    normalizePos: function (pos) {\n        if (pos && pos._id) {\n            pos=pos._id;\n        }\n        var spec = new Spec(pos,'#');\n        var type = spec.type();\n        var id = spec.id();\n        for(var i=0; i<this._objects.length; i++) {\n            var obj = this._objects[i];\n            if (obj && obj._id===id && (!type || obj._type===type)) {\n                break;\n            }\n        }\n        return i;\n    },\n\n    /** Assuming position 0 on the \"left\" and left-to-right writing, the\n      * logic of causal tree insertion is\n      * insert(newEntry, parentWhichIsOnTheLeftSide). */\n    insert: function (spec, pos) {\n        // TODO bulk insert: make'em siblings\n        if (pos===undefined) {\n            pos = -1; // TODO ? this._order.length()\n        }\n        if (pos.constructor!==Number) {\n            pos = this.normalizePos(pos);\n        }\n        if (spec && spec._id) {\n            spec = spec.spec();\n        } else /*if (spec.constructor===String)*/ {\n            spec = new Spec(spec,'#');\n        }\n        // TODO new object\n        var opid = pos===-1 ? '!0' : this._order.tokenAt(pos);\n        // TODO hint pos\n        return this.in(spec+opid);\n    },\n\n    insertAfter: function (obj, pos) {\n        this.insert (obj,pos);\n    },\n\n    insertBefore: function (spec, pos) {\n        if (pos===undefined) {\n            pos = this._order.length();\n        }\n        if (pos.constructor!==Number) {\n            pos = this.normalizePos(pos);\n        }\n        this.insert(spec,pos-1);\n    },\n\n    append: function append (spec) {\n        this.insert(spec,this._order.length()-1);\n    },\n\n    remove: function remove (pos) {\n        if (pos.constructor!==Number) {\n            pos = this.normalizePos(pos);\n        }\n        var hint = Spec.int2base(pos,0);\n        var op = this._order.tokenAt(pos);\n        this.rm(op+'.'+hint); // TODO generic spec quants\n    },\n\n    // Set-compatible, in a sense\n    addObject: function (obj) {\n        this.append(obj);\n    },\n\n    removeObject: function (pos) {\n        this.remove(pos);\n    },\n\n    objectAt: function (i) {\n        return this._objects[i];\n    },\n\n    insertSorted: function (obj, cmp) {\n    },\n\n    setOrder: function (fn) {\n    },\n\n    forEach: function (cb, thisArg) {\n        this._objects.forEach(cb, thisArg);\n    },\n\n    every: function (cb, thisArg) {\n        return this._objects.every(cb, thisArg);\n    },\n\n    filter: function (cb, thisArg) {\n        return this._objects.filter(cb, thisArg);\n    },\n\n    map: function (cb, thisArg) {\n        return this._objects.map(cb, thisArg);\n    }\n\n});\n","/home/travis/build/npmtest/node-npmtest-swarm/node_modules/swarm/lib/Host.js":"\"use strict\";\n\nvar env = require('./env');\nvar Spec = require('./Spec');\nvar Syncable = require('./Syncable');\nvar Pipe = require('./Pipe');\nvar SecondPreciseClock = require('./SecondPreciseClock');\n\n/**\n * Host is (normally) a singleton object registering/coordinating\n * all the local Swarm objects, connecting them to appropriate\n * external uplinks, maintaining clocks, etc.\n * Host itself is not fully synchronized like a Model but still\n * does some event gossiping with peer Hosts.\n * @constructor\n */\nfunction Host(id, ms, storage) {\n    this.objects = {};\n    this.sources = {};\n    this.storage = storage;\n    this._host = this; // :)\n    this._lstn = [','];\n    this._id = id;\n    this._server = /^swarm~.*/.test(id);\n    var clock_fn = env.clockType || SecondPreciseClock;\n    this.clock = new clock_fn(this._id, ms||0);\n\n    if (this.storage) {\n        this.sources[this._id] = this.storage;\n        this.storage._host = this;\n    }\n    delete this.objects[this.spec()];\n\n    if (!env.multihost) {\n        if (env.localhost) {\n            throw new Error('use multihost mode');\n        }\n        env.localhost = this;\n    }\n}\n\nHost.MAX_INT = 9007199254740992;\nHost.MAX_SYNC_TIME = 60 * 60000; // 1 hour (milliseconds)\nHost.HASH_POINTS = 3;\n\nHost.hashDistance = function hashDistance(peer, obj) {\n    if ((obj).constructor !== Number) {\n        if (obj._id) {\n            obj = obj._id;\n        }\n        obj = env.hashfn(obj);\n    }\n    if (peer._id) {\n        peer = peer._id;\n    }\n    var dist = 4294967295;\n    for (var i = 0; i < Host.HASH_POINTS; i++) {\n        var hash = env.hashfn(peer._id + ':' + i);\n        dist = Math.min(dist, hash ^ obj);\n    }\n    return dist;\n};\n\nmodule.exports = Syncable.extend(Host, {\n\n    deliver: function (spec, val, repl) {\n        if (spec.type() !== 'Host') {\n            var typeid = spec.filter('/#');\n            var obj = this.get(typeid);\n            if (obj) {\n                // TODO seeTimestamp()\n                obj.deliver(spec, val, repl);\n            }\n        } else {\n            this._super.deliver.apply(this, arguments);\n        }\n    },\n\n    init: function (spec, val, repl) {\n\n    },\n\n    get: function (spec, callback) {\n        if (spec && spec.constructor === Function && spec.prototype._type) {\n            spec = '/' + spec.prototype._type;\n        }\n        spec = new Spec(spec);\n        var typeid = spec.filter('/#');\n        if (!typeid.has('/')) {\n            throw new Error('invalid spec');\n        }\n        var o = typeid.has('#') && this.objects[typeid];\n        if (!o) {\n            var t = Syncable.types[spec.type()];\n            if (!t) {\n                throw new Error('type unknown: ' + spec);\n            }\n            o = new t(typeid, undefined, this);\n            if (typeof(callback) === 'function') {\n                o.on('.init', callback);\n            }\n        }\n        return o;\n    },\n\n    addSource: function hostAddPeer(spec, peer) {\n        //FIXME when their time is off so tell them so\n        // if (false) { this.clockOffset; }\n        var old = this.sources[peer._id];\n        if (old) {\n            old.deliver(this.newEventSpec('off'), '', this);\n        }\n\n        this.sources[peer._id] = peer;\n        if (spec.op() === 'on') {\n            peer.deliver(this.newEventSpec('reon'), this.clock.ms(), this);\n        }\n        for (var sp in this.objects) {\n            this.objects[sp].checkUplink();\n        }\n    },\n\n    neutrals: {\n        /**\n         * Host forwards on() calls to local objects to support some\n         * shortcut notations, like\n         *          host.on('/Mouse',callback)\n         *          host.on('/Mouse.init',callback)\n         *          host.on('/Mouse#Mickey',callback)\n         *          host.on('/Mouse#Mickey.init',callback)\n         *          host.on('/Mouse#Mickey!baseVersion',repl)\n         *          host.on('/Mouse#Mickey!base.x',trackfn)\n         * The target object may not exist beforehand.\n         * Note that the specifier is actually the second 3sig parameter\n         * (value). The 1st (spec) reflects this /Host.on invocation only.\n         */\n        on: function hostOn(spec, filter, lstn) {\n            if (!filter) {\n                // the subscriber needs \"all the events\"\n                return this.addSource(spec, lstn);\n            }\n\n            if (filter.constructor === Function && filter.id) {\n                filter = new Spec(filter.id, '/');\n            } else if (filter.constructor === String) {\n                filter = new Spec(filter, '.');\n            }\n            // either suscribe to this Host or to some other object\n            if (!filter.has('/') || filter.type() === 'Host') {\n                this._super._neutrals.on.call(this, spec, filter, lstn);\n            } else {\n                var objSpec = new Spec(filter);\n                if (!objSpec.has('#')) {\n                    throw new Error('no id to listen');\n                }\n                objSpec = objSpec.set('.on').set(spec.version(), '!');\n                this.deliver(objSpec, filter, lstn);\n            }\n        },\n\n        reon: function hostReOn(spec, ms, host) {\n            if (spec.type() !== 'Host') {\n                throw new Error('Host.reon(/NotHost.reon)');\n            }\n            this.clock.adjustTime(ms);\n            this.addSource(spec, host);\n        },\n\n        off: function (spec, nothing, peer) {\n            peer.deliver(peer.spec().add(this.time(), '!').add('.reoff'), '', this);\n            this.removeSource(spec, peer);\n        },\n\n        reoff: function hostReOff(spec, nothing, peer) {\n            this.removeSource(spec, peer);\n        }\n\n    }, // neutrals\n\n    removeSource: function (spec, peer) {\n        if (spec.type() !== 'Host') {\n            throw new Error('Host.removeSource(/NoHost)');\n        }\n\n        if (this.sources[peer._id] !== peer) {\n            console.error('peer unknown', peer._id); //throw new Error\n            return;\n        }\n        delete this.sources[peer._id];\n        for (var sp in this.objects) {\n            var obj = this.objects[sp];\n            if (obj.getListenerIndex(peer, true) > -1) {\n                obj.off(sp, '', peer);\n                obj.checkUplink(sp);\n            }\n        }\n    },\n\n\n    /**\n     * Returns an unique Lamport timestamp on every invocation.\n     * Swarm employs 30bit integer Unix-like timestamps starting epoch at\n     * 1 Jan 2010. Timestamps are encoded as 5-char base64 tokens; in case\n     * several events are generated by the same process at the same second\n     * then sequence number is added so a timestamp may be more than 5\n     * chars. The id of the Host (+user~session) is appended to the ts.\n     */\n    time: function () {\n        var ts = this.clock.issueTimestamp();\n        this._version = ts;\n        return ts;\n    },\n\n    /**\n     * Returns an array of sources (caches,storages,uplinks,peers)\n     * a given replica should be subscribed to. This default\n     * implementation uses a simple consistent hashing scheme.\n     * Note that a client may be connected to many servers\n     * (peers), so the uplink selection logic is shared.\n     * @param {Spec} spec some object specifier\n     * @returns {Array} array of currently available uplinks for specified object\n     */\n    getSources: function (spec) {\n        var self = this,\n            uplinks = [],\n            mindist = 4294967295,\n            rePeer = /^swarm~/, // peers, not clients\n            target = env.hashfn(spec),\n            closestPeer = null;\n\n        if (rePeer.test(this._id)) {\n            mindist = Host.hashDistance(this._id, target);\n            closestPeer = this.storage;\n        } else {\n            uplinks.push(self.storage); // client-side cache\n        }\n\n        for (var id in this.sources) {\n            if (!rePeer.test(id)) {\n                continue;\n            }\n            var dist = Host.hashDistance(id, target);\n            if (dist < mindist) {\n                closestPeer = this.sources[id];\n                mindist = dist;\n            }\n        }\n        if (closestPeer) {\n            uplinks.push(closestPeer);\n        }\n        return uplinks;\n    },\n\n    isUplinked: function () {\n        for (var id in this.sources) {\n            if (/^swarm~.*/.test(id)) {\n                return true;\n            }\n        }\n        return false;\n    },\n\n    isServer: function () {\n        return this._server;\n    },\n\n    register: function (obj) {\n        var spec = obj.spec();\n        if (spec in this.objects) {\n            return this.objects[spec];\n        }\n        this.objects[spec] = obj;\n        return obj;\n    },\n\n    unregister: function (obj) {\n        var spec = obj.spec();\n        // TODO unsubscribe from the uplink - swarm-scale gc\n        if (spec in this.objects) {\n            delete this.objects[spec];\n        }\n    },\n\n    // waits for handshake from stream\n    accept: function (stream_or_url, pipe_env) {\n        new Pipe(this, stream_or_url, pipe_env);\n    },\n\n    // initiate handshake with peer\n    connect: function (stream_or_url, pipe_env) {\n        var pipe = new Pipe(this, stream_or_url, pipe_env);\n        pipe.deliver(new Spec('/Host#'+this._id+'!0.on'), '', this); //this.newEventSpec\n        return pipe;\n    },\n\n    disconnect: function (id) {\n        for (var peer_id in this.sources) {\n            if (id && peer_id != id) {\n                continue;\n            }\n            if (peer_id === this._id) {\n                // storage\n                continue;\n            }\n            var peer = this.sources[peer_id];\n            // normally, .off is sent by a downlink\n            peer.deliver(peer.spec().add(this.time(), '!').add('.off'));\n        }\n    },\n\n    close: function (cb) {\n        for(var id in this.sources) {\n            if (id===this._id) {continue;}\n            this.disconnect(id);\n        }\n        if (this.storage) {\n            this.storage.close(cb);\n        } else if (cb) {\n            cb();\n        }\n    },\n\n    checkUplink: function (spec) {\n        //  TBD Host event relay + PEX\n    }\n\n});\n","/home/travis/build/npmtest/node-npmtest-swarm/node_modules/swarm/lib/Pipe.js":"\"use strict\";\n\nvar env = require('./env');\nvar Spec = require('./Spec');\n\n/**\n * A \"pipe\" is a channel to a remote Swarm Host. Pipe's interface\n * mocks a Host except all calls are serialized and sent to the\n * *stream*; any arriving data is parsed and delivered to the\n * local host. The *stream* must support an interface of write(),\n * end() and on('open'|'data'|'close'|'error',fn).  Instead of a\n * *stream*, the caller may supply an *uri*, so the Pipe will\n * create a stream and connect/reconnect as necessary.\n */\n\nfunction Pipe(host, stream, opts) {\n    var self = this;\n    self.opts = opts || {};\n    if (!stream || !host) {\n        throw new Error('new Pipe(host,stream[,opts])');\n    }\n    self._id = null;\n    self.host = host;\n    // uplink/downlink state flag;\n    //  true: this side initiated handshake >.on <.reon\n    //  false: this side received handshake <.on >.reon\n    //  undefined: nothing sent/received OR had a .reoff\n    this.isOnSent = undefined;\n    this.reconnectDelay = self.opts.reconnectDelay || 1000;\n    self.serializer = self.opts.serializer || JSON;\n    self.katimer = null;\n    self.send_timer = null;\n    self.lastSendTS = self.lastRecvTS = self.time();\n    self.bundle = {};\n    // don't send immediately, delay to bundle more messages\n    self.delay = self.opts.delay || -1;\n    //self.reconnectDelay = self.opts.reconnectDelay || 1000;\n    if (typeof(stream.write) !== 'function') { // TODO nicer\n        var url = stream.toString();\n        var m = url.match(/(\\w+):.*/);\n        if (!m) {\n            throw new Error('invalid url ' + url);\n        }\n        var proto = m[1].toLowerCase();\n        var fn = env.streams[proto];\n        if (!fn) {\n            throw new Error('protocol not supported: ' + proto);\n        }\n        self.url = url;\n        stream = new fn(url);\n    }\n    self.connect(stream);\n}\n\nmodule.exports = Pipe;\n//env.streams = {};\nPipe.TIMEOUT = 60000; //ms\n\nPipe.prototype.connect = function pc(stream) {\n    var self = this;\n    self.stream = stream;\n\n    self.stream.on('data', function onMsg(data) {\n        data = data.toString();\n        env.trace && env.log(dotIn, data, this, this.host);\n        self.lastRecvTS = self.time();\n        var json = self.serializer.parse(data);\n        try {\n            self._id ? self.parseBundle(json) : self.parseHandshake(json);\n        } catch (ex) {\n            console.error('error processing message', ex, ex.stack);\n            //this.deliver(this.host.newEventSpec('error'), ex.message);\n            this.close();\n        }\n        self.reconnectDelay = self.opts.reconnectDelay || 1000;\n    });\n\n    self.stream.on('close', function onConnectionClosed(reason) {\n        self.stream = null; // needs no further attention\n        self.close(\"stream closed\");\n    });\n\n    self.stream.on('error', function (err) {\n        self.close('stream error event: ' + err);\n    });\n\n    self.katimer = setInterval(self.keepAliveFn.bind(self), (Pipe.TIMEOUT / 4 + Math.random() * 100) | 0);\n\n    // NOPE client only finally, initiate handshake\n    // self.host.connect(self);\n\n};\n\nPipe.prototype.keepAliveFn = function () {\n    var now = this.time(),\n        sinceRecv = now - this.lastRecvTS,\n        sinceSend = now - this.lastSendTS;\n    if (sinceSend > Pipe.TIMEOUT / 2) {\n        this.sendBundle();\n    }\n    if (sinceRecv > Pipe.TIMEOUT) {\n        this.close(\"stream timeout\");\n    }\n};\n\nPipe.prototype.parseHandshake = function ph(handshake) {\n    var spec, value, key;\n    for (key in handshake) {\n        spec = new Spec(key);\n        value = handshake[key];\n        break; // 8)-\n    }\n    if (!spec) {\n        throw new Error('handshake has no spec');\n    }\n    if (spec.type() !== 'Host') {\n        env.warn(\"non-Host handshake\");\n    }\n    if (spec.id() === this.host._id) {\n        throw new Error('self hs');\n    }\n    this._id = spec.id();\n    var op = spec.op();\n    var evspec = spec.set(this.host._id, '#');\n\n    if (op in {on: 1, reon: 1, off: 1, reoff: 1}) {// access denied TODO\n        this.host.deliver(evspec, value, this);\n    } else {\n        throw new Error('invalid handshake');\n    }\n};\n\n/**\n * Close the underlying stream.\n * Schedule new Pipe creation (when error passed).\n * note: may be invoked multiple times\n * @param {Error|string} error\n */\nPipe.prototype.close = function pc(error) {\n    env.log(dotClose, error ? 'error: ' + error : 'correct', this, this.host);\n    if (error && this.host && this.url) {\n        var uplink_uri = this.url,\n            host = this.host,\n            pipe_opts = this.opts;\n        //reconnect delay for next disconnection\n        pipe_opts.reconnectDelay = Math.min(30000, this.reconnectDelay << 1);\n        // schedule a retry\n        setTimeout(function () {\n            host.connect(uplink_uri, pipe_opts);\n        }, this.reconnectDelay);\n\n        this.url = null; //to prevent second reconnection timer\n    }\n    if (this.host) {\n        if (this.isOnSent !== undefined && this._id) {\n            // emulate normal off\n            var offspec = this.host.newEventSpec(this.isOnSent ? 'off' : 'reoff');\n            this.host.deliver(offspec, '', this);\n        }\n        this.host = null; // can't pass any more messages\n    }\n    if (this.katimer) {\n        clearInterval(this.katimer);\n        this.katimer = null;\n    }\n    if (this.stream) {\n        try {\n            this.stream.close();\n        } catch (ex) {}\n        this.stream = null;\n    }\n    this._id = null;\n};\n\n/**\n * Sends operation to remote\n */\nPipe.prototype.deliver = function pd(spec, val, src) {\n    var self = this;\n    val && val.constructor === Spec && (val = val.toString());\n    if (spec.type() === 'Host') {\n        switch (spec.op()) {\n        case 'reoff':\n            setTimeout(function itsOverReally() {\n                self.isOnSent = undefined;\n                self.close();\n            }, 1);\n            break;\n        case 'off':\n            setTimeout(function tickingBomb() {\n                self.close();\n            }, 5000);\n            break;\n        case 'on':\n            this.isOnSent = true;\n        case 'reon':\n            this.isOnSent = false;\n        }\n    }\n    this.bundle[spec] = val === undefined ? null : val; // TODO aggregation\n    if (this.delay === -1) {\n        this.sendBundle();\n    } else if (!this.send_timer) {\n        var now = this.time(),\n            gap = now - this.lastSendTS,\n            timeout = gap > this.delay ? this.delay : this.delay - gap;\n        this.send_timer = setTimeout(this.sendBundle.bind(this), timeout); // hmmm...\n    } // else {} // just wait\n};\n\n/** @returns {number} milliseconds as an int */\nPipe.prototype.time = function () { return new Date().getTime(); };\n\n/**\n * @returns {Spec|string} remote host spec \"/Host#peer_id\" or empty string (when not handshaken yet)\n */\nPipe.prototype.spec = function () {\n    return this._id ? new Spec('/Host#' + this._id) : '';\n};\n/**\n * @param {*} bundle is a bunch of operations in a form {operation_spec: operation_params_object}\n * @private\n */\nPipe.prototype.parseBundle = function pb(bundle) {\n    var spec_list = [], spec, self = this;\n    //parse specifiers\n    for (spec in bundle) { spec && spec_list.push(new Spec(spec)); }\n    spec_list.sort().reverse();\n    while (spec = spec_list.pop()) {\n        spec = Spec.as(spec);\n        this.host.deliver(spec, bundle[spec], this);\n        if (spec.type() === 'Host' && spec.op() === 'reoff') { //TODO check #id\n            setTimeout(function () {\n                self.isOnSent = undefined;\n                self.close();\n            }, 1);\n        }\n    }\n};\n\nvar dotIn = new Spec('/Pipe.in');\nvar dotOut = new Spec('/Pipe.out');\nvar dotClose = new Spec('/Pipe.close');\n//var dotOpen = new Spec('/Pipe.open');\n\n/**\n * Sends operations buffered in this.bundle as a bundle {operation_spec: operation_params_object}\n * @private\n */\nPipe.prototype.sendBundle = function pS() {\n    var payload = this.serializer.stringify(this.bundle);\n    this.bundle = {};\n    if (!this.stream) {\n        this.send_timer = null;\n        return; // too late\n    }\n\n    try {\n        env.trace && env.log(dotOut, payload, this, this.host);\n        this.stream.write(payload);\n        this.lastSendTS = this.time();\n    } catch (ex) {\n        env.error('stream error on write: ' + ex, ex.stack);\n        if (this._id) {\n            this.close('stream error', ex);\n        }\n    } finally {\n        this.send_timer = null;\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-swarm/node_modules/swarm/lib/SecondPreciseClock.js":"\"use strict\";\n\nvar Spec = require('./Spec');\n\n/** Swarm is based on the Lamport model of time and events in a\n  * distributed system, so Lamport timestamps are essential to\n  * its functioning. In most of the cases, it is useful to\n  * use actuall wall clock time to create timestamps. This\n  * class creates second-precise Lamport timestamps.\n  * Timestamp ordering is alphanumeric, length may vary.\n  *\n  * @param processId id of the process/clock to add to every\n  *        timestamp (like !timeseq+gritzko~ssn, where gritzko\n  *        is the user and ssn is a session id, so processId\n  *        is \"gritzko~ssn\").\n  * @param initTime normally, that is server-supplied timestamp\n  *        to init our time offset; there is no guarantee about\n  *        clock correctness on the client side\n  */\nvar SecondPreciseClock = function (processId, timeOffsetMs) {\n    if (!Spec.reTok.test(processId)) {\n        throw new Error('invalid process id: '+processId);\n    }\n    this.id = processId;\n    // sometimes we assume our local clock has some offset\n    this.clockOffsetMs = 0;\n    this.lastTimestamp = '';\n    // although we try hard to use wall clock time, we must\n    // obey Lamport logical clock rules, in particular our\n    // timestamps must be greater than any other timestamps\n    // previously seen\n    this.lastTimeSeen = 0;\n    this.lastSeqSeen = 0;\n    if (timeOffsetMs) {\n        this.clockOffsetMs = timeOffsetMs;\n    }\n};\n\nvar epochDate = new Date(\"Wed, 01 Jan 2014 00:00:00 GMT\");\nSecondPreciseClock.EPOCH = epochDate.getTime();\n\nSecondPreciseClock.prototype.adjustTime = function (trueMs) {\n    var localTime = this.ms();\n    var clockOffsetMs = trueMs - localTime;\n    this.clockOffsetMs = clockOffsetMs;\n    var lastTS = this.lastTimeSeen;\n    this.lastTimeSeen = 0;\n    this.lastSeqSeen = 0;\n    this.lastTimestamp = '';\n    if ( this.seconds()+1 < lastTS ) {\n        console.error(\"risky clock reset\",this.lastTimestamp);\n    }\n};\n\nSecondPreciseClock.prototype.ms = function () {\n    var millis = new Date().getTime();\n    millis -= SecondPreciseClock.EPOCH;\n    return millis;\n};\n\nSecondPreciseClock.prototype.seconds = function () {\n    var millis = this.ms();\n    millis += this.clockOffsetMs;\n    return (millis/1000) | 0;\n};\n\nSecondPreciseClock.prototype.issueTimestamp = function time () {\n    var res = this.seconds();\n    if (this.lastTimeSeen>res) { res = this.lastTimeSeen; }\n    if (res>this.lastTimeSeen) { this.lastSeqSeen = -1; }\n    this.lastTimeSeen = res;\n    var seq = ++this.lastSeqSeen;\n    if (seq>=(1<<12)) {throw new Error('max event freq is 4000Hz');}\n\n    var baseTimeSeq = Spec.int2base(res, 5);\n    if (seq>0) { baseTimeSeq+=Spec.int2base(seq, 2); }\n\n    this.lastTimestamp = baseTimeSeq + '+' + this.id;\n    return this.lastTimestamp;\n};\n\n//SecondPreciseClock.reQTokExt = new RegExp(Spec.rsTokExt); // no 'g'\n\nSecondPreciseClock.prototype.parseTimestamp = function parse (ts) {\n    var m = ts.match(Spec.reTokExt);\n    if (!m) {throw new Error('malformed timestamp: '+ts);}\n    var timeseq=m[1]; //, process=m[2];\n    var time = timeseq.substr(0,5), seq = timeseq.substr(5);\n    if (seq&&seq.length!==2) {\n        throw new Error('malformed timestamp value: '+timeseq);\n    }\n    return {\n        time: Spec.base2int(time),\n        seq: seq ? Spec.base2int(seq) : 0\n    };\n};\n\n/** Freshly issued Lamport logical tiemstamps must be greater than\n    any timestamps previously seen. */\nSecondPreciseClock.prototype.checkTimestamp = function see (ts) {\n    if (ts<this.lastTimestamp) { return true; }\n    var parsed = this.parseTimestamp(ts);\n    if (parsed.time<this.lastTimeSeen) { return true; }\n    var sec = this.seconds();\n    if (parsed.time>sec+1) {\n        return false; // back to the future\n    }\n    this.lastTimeSeen = parsed.time;\n    this.lastSeqSeen = parsed.seq;\n    return true;\n};\n\nSecondPreciseClock.prototype.timestamp2date = function (ts) {\n    var parsed = this.parseTimestamp(ts);\n    var millis = parsed.time * 1000 + SecondPreciseClock.EPOCH;\n    return new Date(millis);\n};\n\n\nmodule.exports = SecondPreciseClock;\n","/home/travis/build/npmtest/node-npmtest-swarm/node_modules/swarm/lib/Storage.js":"\"use strict\";\n\nvar Syncable = require('./Syncable');\n\nfunction Storage(async) {\n    this.async = !!async || false;\n    this.states = {};\n    this.tails = {};\n    this.counts = {};\n    this._host = null;\n    // many implementations do not push changes\n    // so there are no listeners\n    this.lstn = null;\n    this._id = 'some_storage';\n}\nmodule.exports = Storage;\nStorage.prototype.MAX_LOG_SIZE = 10;\nStorage.prototype.isRoot = true; // may create global objects\n\nStorage.prototype.deliver = function (spec, value, src) {\n    var ret;\n    switch (spec.op()) {\n        // A storage is always an \"uplink\" so it never receives reon, reoff.\n    case 'on':\n        ret = this.on(spec, value, src); break;\n    case 'off':\n        ret = this.off(spec, value, src); break;\n    case 'init':\n        if (value._version) { // state\n            ret = this.init(spec, value, src);\n        } else { // patch\n            var ti = spec.filter('/#');\n            var specs = [], s;\n            for(s in value._tail) {  specs.push(s);  }\n            specs.sort();\n            while (s=specs.pop()) {\n                ret = this.anyOp( ti.add(s), value._tail[s], src);\n            }\n        }\n        break;\n    default:\n        ret = this.anyOp(spec, value, src);\n    }\n    return ret;\n};\n\nStorage.prototype.on = function storageOn (spec, base, src) {\n    var ti = spec.filter('/#');\n\n    if (this.lstn) {\n        var ls = this.lstn[ti];\n        if (ls === undefined) {\n            ls = src;\n        } else if (ls !== src) {\n            if (ls.constructor !== Array) {\n                ls = [ls];\n            }\n            ls.push(src);\n        }\n        this.lstn[ti] = ls;\n    }\n\n    var self = this;\n    var state;\n    var tail;\n\n    function sendResponse() {\n        if (!state) {\n            if (self.isRoot) {// && !spec.token('#').ext) {\n                // make 0 state for a global object TODO move to Host\n                state = {_version: '!0'};\n            }\n        }\n        if (tail) {\n            if (!state) {state={};}\n            state._tail = state._tail || {};\n            for (var s in tail) {\n                state._tail[s] = tail[s];\n            }\n        }\n        var tiv = ti.add(spec.version(), '!');\n        if (state) {\n            src.deliver(tiv.add('.init'), state, self);\n            src.deliver(tiv.add('.reon'), Syncable.stateVersionVector(state), self); // TODO and the tail\n        } else {\n            src.deliver(tiv.add('.reon'), '!0', self); // state unknown\n        }\n    }\n\n    this.readState(ti, function (err, s) {\n        state = s || null;\n        if (tail !== undefined) {\n            sendResponse();\n        }\n    });\n\n    this.readOps(ti, function (err, t) {\n        tail = t || null;\n        if (state !== undefined) {\n            sendResponse();\n        }\n    });\n};\n\n\nStorage.prototype.off = function (spec, value, src) {\n    if (!this.lstn) {\n        return;\n    }\n    var ti = spec.filter('/#');\n    var ls = this.lstn[ti];\n    if (ls === src) {\n        delete this.lstn[ti];\n    } else if (ls && ls.constructor === Array) {\n        var cleared = ls.filter(function (v) {return v !== src;});\n        if (cleared.length) {\n            this.lstn[ti] = cleared;\n        } else {\n            delete this.lstn[ti];\n        }\n    }\n};\n\nStorage.prototype.init = function (spec, state, src) {\n    var ti = spec.filter('/#'), self=this;\n    var saveops = this.tails[ti];\n    this.writeState(spec, state, function (err) {\n        if (err) {\n            console.error('state dump error:', err);\n        } else {\n            var tail = self.tails[ti] || (self.tails[ti] = {});\n            for(var op in saveops) { // OK, let's keep that in the log\n                tail[op] = saveops[op];\n            }\n        }\n    });\n};\n\n\nStorage.prototype.anyOp = function (spec, value, src) {\n    var self = this;\n    var ti = spec.filter('/#');\n    this.writeOp(spec, value, function (err) {\n        if (err) {\n            this.close(err); // the log is sacred\n        }\n    });\n    self.counts[ti] = self.counts[ti] || 0;\n    if (++self.counts[ti]>self.MAX_LOG_SIZE) {\n        // The storage piggybacks on the object's state/log handling logic\n        // First, it adds an op to the log tail unless the log is too long...\n        // ...otherwise it sends back a subscription effectively requesting\n        // the state, on state arrival zeroes the tail.\n        delete self.counts[ti];\n        src.deliver(spec.set('.reon'), '!0.init', self);\n    }\n};\n\n\n// In a real storage implementation, state and log often go into\n// different backends, e.g. the state is saved to SQL/NoSQL db,\n// while the log may live in a key-value storage.\n// As long as the state has sufficient versioning info saved with\n// it (like a version vector), we may purge the log lazily, once\n// we are sure that the state is reliably saved. So, the log may\n// overlap with the state (some ops are already applied). That\n// provides some necessary resilience to workaround the lack of\n// transactions across backends.\n// In case third parties may write to the backend, go figure\n// some way to deal with it (e.g. make a retrofit operation).\nStorage.prototype.writeState = function (spec, state, cb) {\n    var ti = spec.filter('/#');\n    this.states[ti] = JSON.stringify(state);\n    // tail is zeroed on state flush\n    delete this.tails[ti];\n    // callback is mandatory\n    cb();\n};\n\nStorage.prototype.writeOp = function (spec, value, cb) {\n    var ti = spec.filter('/#');\n    var vm = spec.filter('!.');\n    var tail = this.tails[ti] || (this.tails[ti] = {});\n    if (tail[vm]) {\n        console.error('op replay @storage'+vm+new Error().stack);\n    }\n    tail[vm] = JSON.stringify(value);\n    cb();\n};\n\nStorage.prototype.readState = function (ti, callback) {\n    var state = JSON.parse(this.states[ti] || null);\n\n    function sendResponse() {\n        callback(null, state);\n    }\n\n    // may force async behavior\n    this.async ? setTimeout(sendResponse, 1) : sendResponse();\n};\n\nStorage.prototype.readOps = function (ti, callback) {\n    var tail = JSON.parse(this.tails[ti] || null);\n    callback(null, tail);\n};\n\nStorage.prototype.close = function (callback) {\n    if (callback) { callback(); }\n};\n\nStorage.prototype.emit = function (spec,value) {\n    var ti = spec.filter('/#');\n    var ln = this.lstn[ti];\n    if (!ln) {return;}\n    if (ln && ln.constructor===Array) {\n        for(var i=0; ln && i<ln.length; i++) {\n            var l = ln[i];\n            if (l && l.constructor===Function) {\n                l(spec,value,this);\n            } else if (l && l.deliver) {\n                l.deliver(spec,value,this);\n            }\n        }\n    } else if (ln && ln.deliver) {\n        ln.deliver(spec,value,this);\n    } else if (ln && ln.constructor===Function) {\n        ln(spec,value,this);\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-swarm/node_modules/swarm/lib/FileStorage.js":"\"use strict\";\nvar fs = require('fs');\nvar path = require('path');\nvar env = require('./env');\nvar Spec = require('./Spec');\nvar Storage = require('./Storage');\n\n/**\n * An improvised filesystem-based storage implementation.\n * Objects are saved into separate files in a hashed directory\n * tree. Ongoing operations are streamed into a log file.\n * One can go surprisingly far with this kind of an approach.\n * https://news.ycombinator.com/item?id=7872239 */\nfunction FileStorage (dir) {\n    Storage.call(this);\n    this._host = null; //will be set during Host creation\n    this.dir = path.resolve(dir);\n    if (!fs.existsSync(this.dir)) {\n        fs.mkdirSync(this.dir);\n    }\n    this._id = 'file';\n    this.tail = {};\n\n    this.loadLog();\n    this.rotateLog();\n}\nFileStorage.prototype = new Storage();\nmodule.exports = FileStorage;\n\nFileStorage.prototype.stateFileName = function (spec) {\n    var base = path.resolve(this.dir, spec.type());\n    var file = path.resolve(base, spec.id());\n    return file; // TODO hashing?\n};\n\nFileStorage.prototype.logFileName = function () {\n    return path.resolve(this.dir, \"_log\");\n};\n\nFileStorage.prototype.writeState = function (spec, state, cb) {\n    var self = this;\n    var ti = spec.filter('/#');\n    var fileName = this.stateFileName(ti);\n    var dir = path.dirname(fileName);\n    if (!fs.existsSync(dir)) {\n        fs.mkdirSync(dir);\n    }\n    var save = JSON.stringify(state, undefined, 2);\n    // dump JSON to the tmp file\n    delete self.tails[ti]; // TODO save 'em in case write fails\n    fs.writeFile(fileName, save, function onSave(err) {\n        if (err) {\n            console.error(\"failed to flush state; can't trim the log\", err);\n        }\n        cb(err);\n    });\n};\n\nFileStorage.prototype.writeOp = function (spec, value, cb) {\n    var self = this;\n    var ti = spec.filter('/#');\n    var vm = spec.filter('!.');\n    var tail = this.tails[ti] || (this.tails[ti] = {});\n    if (vm in tail) {\n        console.error('op replay @storage',vm,new Error().stack);\n        return;\n    }\n    var clone = JSON.parse(JSON.stringify(value)); // FIXME performance please\n    tail[vm] = clone;\n    var record = ',\\n\"'+spec+'\":\\t'+JSON.stringify(clone);\n    this.logFile.write (record, function onFail(err) {\n        if (err) { self.close(null,err); }\n        cb(err);\n    });\n};\n\n\nFileStorage.prototype.readState = function (ti, callback) {\n    var statefn = this.stateFileName(ti);\n    // read in the state\n    fs.readFile(statefn, function onRead(err, data) { // FIXME fascism\n        var state = err ? {_version: '!0'} : JSON.parse(data.toString());\n        callback(null,state||null); // important: no state is \"null\"\n    });\n};\n\n\nFileStorage.prototype.readOps = function (ti, callback) {\n    var tail = this.tails[ti];\n    if (tail) {\n        var unjsoned = {};\n        for(var key in tail) {\n            unjsoned[key] = tail[key];\n        }\n        tail = unjsoned;\n    }\n    callback(null, tail||null);\n};\n\n\nFileStorage.prototype.close = function (callback,error) {\n    if (error) {\n        console.log(\"fatal IO error\", error);\n    }\n    if (this.logFile) {\n        this.rotateLog(true, callback);\n    }\n};\n\n\nFileStorage.prototype.rotateLog = function (noOpen, callback) {\n    var self = this;\n    if (this.logFile) {\n        this.logFile.end('}', callback);\n        this.logFile = null;\n        callback = undefined;\n    }\n\n    if (!noOpen) {\n\n        if (fs.existsSync(this.logFileName())) {\n            fs.rename(this.logFileName(),this.logFileName()+'.bak');\n        }\n        this.logFile = fs.createWriteStream(this.logFileName()); // TODO file swap\n        this.logFile.on('error', function (err) {\n            self.close(null,err);\n        });\n\n        var json = JSON.stringify(this.tails, undefined, 2);\n        json = '{\"\":\\n' + json; // open-ended JSON\n\n        this.logFile.write (json, function onFail(err) {\n            if (err) { self.close(null,err); }\n        });\n\n    }\n\n    if (callback) {\n        callback();\n    }\n\n};\n\nFileStorage.prototype.loadLog = function () {\n    if ( !fs.existsSync(this.logFileName()) ) {\n        return;\n    }\n    var json = fs.readFileSync(this.logFileName(), {encoding:\"utf8\"});\n    if (!json) { return; }\n    var log;\n    try {\n        log = JSON.parse(json);\n    } catch (ex) {\n        // open-ended JSON\n        log = JSON.parse(json + '}');\n    }\n    this.tails = log[''];\n    delete log[''];\n    for(var s in log) {\n        var spec = new Spec(s);\n        if (spec.pattern()==='/#!.') {\n            var ti = spec.filter('/#');\n            var vm = spec.filter('!.');\n            var tail = this.tails[ti] || (this.tails[ti] = {});\n            tail[vm]  = log[spec];\n        }\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-swarm/node_modules/swarm/lib/LevelStorage.js":"\"use strict\";\nvar env = require('./env');\nvar Spec = require('./Spec');\nvar Storage = require('./Storage');\n\n/** LevelDB is a perfect local storage: string-indexed, alphanumerically\n  * sorted, stores JSON with minimal overhead. Last but not least, has\n  * the same interface as IndexedDB. */\nfunction LevelStorage (id, options, callback) {\n    Storage.call(this);\n    this.options = options;\n    this._host = null; // will be set by the Host\n    this.db = options.db;\n    this._id = id;\n    this.filename = null;\n    if (this.db.constructor===Function) {\n        this.db = this.db(options.path||id);\n    }\n    this.logtails = {};\n}\nLevelStorage.prototype = new Storage();\nmodule.exports = LevelStorage;\nLevelStorage.prototype.isRoot = env.isServer;\n\nLevelStorage.prototype.open = function (callback) {\n    this.db.open(this.options.dbOptions||{}, callback);\n};\n\nLevelStorage.prototype.writeState = function (spec, state, cb) {\n    console.log('>STATE',state);\n    var self = this;\n    var ti = spec.filter('/#');\n    //var save = JSON.stringify(state, undefined, 2);\n    if (!self.db) {\n        console.warn('the storage is not open', this._host&&this._host._id);\n        return;\n    }\n\n    var json = JSON.stringify(state);\n    var cleanup = [], key;\n    if (ti in this.logtails) {\n        while (key = this.logtails[ti].pop()) {\n            cleanup.push({\n                key: key,\n                type: 'del'\n            });\n        }\n        delete this.logtails[ti];\n    }\n    console.log('>FLUSH',json,cleanup.length);\n    self.db.put(ti, json, function onSave(err) {\n        if (!err && cleanup.length && self.db) {\n            console.log('>CLEAN',cleanup);\n            self.db.batch(cleanup, function(err){\n                err && console.error('log trimming failed',err);\n            });\n        }\n        err && console.error(\"state write error\", err);\n        cb(err);\n    });\n\n};\n\nLevelStorage.prototype.writeOp = function (spec, value, cb) {\n    var json = JSON.stringify(value);\n    var ti = spec.filter('/#');\n    if (!this.logtails[ti]) {\n        this.logtails[ti] = [];\n    }\n    this.logtails[ti].push(spec);\n    console.log('>OP',spec.toString(),json);\n    this.db.put(spec.toString(), json, function (err){\n        err && console.error('op write error',err);\n        cb(err);\n    });\n};\n\n\nLevelStorage.prototype.readState = function (ti, callback) {\n    var self = this;\n    ti = ti.toString();\n    this.db.get(ti, {asBuffer:false}, function(err,value){\n\n        var notFound = err && /^NotFound/.test(err.message);\n        if (err && !notFound) { return callback(err); }\n\n        if ((err && notFound) || !value) {\n            err = null;\n            value = {_version: '!0'};\n        } else {\n            value = JSON.parse(value);\n        }\n\n        console.log('<STATE',self._host && self._host._id,value);\n        callback(err, value);\n    });\n};\n\n\nLevelStorage.prototype.readOps = function (ti, callback) {\n    var self = this;\n    var tail = {}, log = [];\n    var i = this.db.iterator({\n        gt: ti+' ',\n        lt: ti+'0'\n    });\n    i.next(function recv(err,key,value){\n        if (err) {\n            callback(err);\n            i.end(function(err){});\n        } else if (key) {\n            var spec = new Spec(key);\n            var vo = spec.filter('!.');\n            tail[vo] = JSON.parse(value.toString());\n            log.push(vo);\n            i.next(recv);\n        } else {\n            console.log('<TAIL',self._host && self._host._id,tail);\n            self.logtails[ti] = ti in self.logtails ?\n                self.logtails[ti].concat(log) : log;\n            callback(null, tail);\n            i.end(function(err){\n                err && console.error(\"can't close an iter\",err);\n            });\n        }\n    });\n};\n\nLevelStorage.prototype.off = function (spec,val,src) {\n    var ti = spec.filter('/#');\n    delete this.logtails[ti];\n    Storage.prototype.off.call(this,spec,val,src);\n};\n\nLevelStorage.prototype.close = function (callback,error) { // FIXME\n    if (error) {\n        console.log(\"fatal IO error\", error);\n    }\n    if (this.db) {\n        this.db.close(callback);\n        this.db = null;\n    } else {\n        callback(); // closed already\n    }\n};\n\n/*\nprocess.on('uncaughtException', function(err) {\n    CLOSE ALL DATABASES\n});\n*/\n","/home/travis/build/npmtest/node-npmtest-swarm/node_modules/swarm/lib/EinarosWSStream.js":"\"use strict\";\n\nvar env = require('./env');\nvar ws_lib = require('ws');\n\nfunction EinarosWSStream(ws) {\n    var self = this,\n        ln = this.lstn = {},\n        buf = [];\n\n    if (typeof ws === 'string') { // url passed\n        ws = new ws_lib(ws);\n    }\n    this.ws = ws;\n    if (ws.readyState !== 1/*WebSocket.OPEN*/) {\n        this.buf = buf; //will wait for \"open\"\n    }\n    ws.on('open', function () {\n        buf.reverse();\n        self.buf = null;\n        while (buf.length) {\n            self.write(buf.pop());\n        }\n    });\n    ws.on('close', function () { ln.close && ln.close(); });\n    ws.on('message', function (msg) {\n        try {\n            ln.data && ln.data(msg);\n        } catch (ex) {\n            console.error('message processing fails', ex);\n            ln.error && ln.error(ex.message);\n        }\n    });\n    ws.on('error', function (msg) { ln.error && ln.error(msg); });\n}\n\nmodule.exports = EinarosWSStream;\n\nEinarosWSStream.prototype.on = function (evname, fn) {\n    if (evname in this.lstn) {\n        throw new Error('not supported');\n    }\n    this.lstn[evname] = fn;\n};\n\nEinarosWSStream.prototype.write = function (data) {\n    if (this.buf) {\n        this.buf.push(data.toString());\n    } else {\n        this.ws.send(data.toString());\n    }\n};\n\nenv.streams.ws = env.streams.wss = EinarosWSStream;\n","/home/travis/build/npmtest/node-npmtest-swarm/node_modules/swarm/lib/ReactMixin.js":"\"use strict\";\n\nvar env = require('./env');\nvar Spec = require('./Spec');\n\nmodule.exports = {\n\n    deliver: function (spec,val,source) {\n        var sync = this.sync;\n        var version = sync._version;\n        if (this.props.listenEntries) {\n            var opId = '!' + spec.version();\n            if (version !== opId) {\n                version = opId;\n            }\n        }\n        this.setState({version: version});\n    },\n\n    componentWillMount: function () {\n        var spec = this.props.spec || this.props.key;\n        if (!Spec.is(spec)) {\n            if (spec && this.constructor.modelType) {\n                var id = spec;\n                spec = new Spec(this.constructor.modelType,'/'); // TODO fn!!!\n                spec = spec.add(id,'#');\n            } else {\n                throw new Error('not a specifier: '+spec+' at '+this._rootNodeID);\n            }\n        }\n        this.sync = env.localhost.get(spec);\n        this.setState({version:''});\n        if (!env.isServer) {\n            var sync = this.sync;\n            sync.on('init', this); // TODO single listener\n            sync.on(this);\n            if (this.props.listenEntries) {\n                sync.onObjectEvent(this);\n            }\n        }\n    },\n\n    componentWillUnmount: function () {\n        if (!env.isServer) {\n            var sync = this.sync;\n            sync.off(this);\n            sync.off(this); // FIXME: remove after TODO: prevent second subscription\n            if (this.props.listenEntries) {\n                sync.offObjectEvent(this);\n            }\n        }\n    },\n\n    shouldComponentUpdate: function (nextProps, nextState) {\n        return this.props !== nextProps || this.state.version !== nextState.version;\n    }\n\n};\n","/home/travis/build/npmtest/node-npmtest-swarm/node_modules/swarm/lib/AsyncLoopbackConnection.js":"\"use strict\";\n\nvar env = require('./env');\n\nfunction AsyncLoopbackConnection(url) {\n    var m = url.match(/loopback:(\\w+)/);\n    if (!m) {\n        throw new Error('invalid url');\n    }\n    this.id = m[1];\n    this.lstn = {};\n    this.queue = [];\n    if (this.id in AsyncLoopbackConnection.pipes) {\n        throw new Error('duplicate');\n    }\n    AsyncLoopbackConnection.pipes[this.id] = this;\n    var pair = this.pair();\n    if (pair && pair.queue.length) {\n        pair.write();\n    }\n}\nAsyncLoopbackConnection.pipes = {};\n\nenv.streams.loopback = AsyncLoopbackConnection;\n\nAsyncLoopbackConnection.prototype.pair = function () {\n    var pairId = this.id.match(/./g).reverse().join('');\n    return AsyncLoopbackConnection.pipes[pairId];\n};\n\nAsyncLoopbackConnection.prototype.on = function (evname, fn) {\n    if (evname in this.lstn) {\n        throw new Error('multiple listeners not supported');\n    }\n    this.lstn[evname] = fn;\n};\n\nAsyncLoopbackConnection.prototype.receive = function (string) {\n    this.lstn.data && this.lstn.data(string);\n};\n\nAsyncLoopbackConnection.prototype.write = function (obj) {\n    var self = this;\n    obj && self.queue.push(obj.toString());\n    setTimeout(function () {\n        var pair = self.pair();\n        if (!pair) {\n            return;\n        }\n        while (self.queue.length) {\n            pair.receive(self.queue.shift());\n        }\n    }, 1);\n};\n\nAsyncLoopbackConnection.prototype.close = function () {\n    delete AsyncLoopbackConnection.pipes[this.id];\n    var pair = this.pair();\n    pair && pair.close();\n    this.lstn.close && this.lstn.close();\n};\n","/home/travis/build/npmtest/node-npmtest-swarm/node_modules/swarm/lib/ce.js":"/* jshint ignore: start */\n// FIXME UPDATE cherrypick\n\nfunction format2str (format) {\n}\n\nfunction htmlesc (text) {\n    return text;\n}\n\n/// range/ids -???  first, all   then...\n\nfunction rtf2txt (rtf) {\n    var txt = rtf.filter(function(o){ return o && o.constructor===String });\n    return txt.join('');\n}\n\nfunction meta2attstr (meta) {\n    var ret = [], styles={}, classes={}, atts={}, structs={};\n    var kv = {':':styles,'_':classes,'=':atts,'s':structs};\n    var re_meta = /^(\\w[\\w_\\-]*)([:_=]?)$/, m;\n    for(key in meta)\n        if (m=re_meta.exec(key))\n            kv [m[2]||'s'] [m[1]] = meta[key];\n\n    ret.push(' class=\"');\n    for (var c in classes)\n        ret.push(c, '_', classes[c], ' ');\n    ret.pop()===' ' && ret.push('\"');\n\n    ret.push(' style=\"');\n    for (var s in styles)\n        ret.push(s, ':', styles[s], ';');\n    ret.pop() === ';' && ret.push('\"');\n\n    for (var a in atts)\n        ret.push(' ', a, '=\"', atts[a], '\"'); // TODO esc \"\n\n    return ret.join('');\n};\n\n\nfunction rtf2html (origRTF) { // TODO meta_in, indent\n    !origRTF && (origRTF='');\n    origRTF.constructor===String && (origRTF=[origRTF]);\n    var html = [], openTag = null, rtf=origRTF.slice(0).reverse();\n    var frg, format={};\n    while (frg=rtf.pop()) {\n        if (frg.constructor===Object) {\n            format = frg;\n            continue;\n        } else if (frg.constructor!==String)\n            throw new Error('format violation: ',frg);\n        var head = frg.charAt(0);\n        if (head==='\\n') {\n            // plant open/close // use struct markers\n            if (openTag) {\n                html.push('</',openTag,'>\\n');\n                openTag = null;\n            }\n            // TODO check structf for indent/nesting\n            if (format.head)\n                openTag = 'h'+format.head;\n            else\n                openTag = 'p';\n            html.push('<',openTag,'>'); // TODO pid\n            frg = frg.substr(1);\n        }\n        //find next struct (lookahead; had \\n => check for \\t)\n        var n = frg.indexOf('\\n',1);\n        if (n!==-1) { // repair\n            rtf.push(frg.substr(n));\n            frg = frg.substr(0,n);\n        }\n        var atts = meta2attstr(format);\n        html.push('<span',atts,'>',htmlesc(frg),'</span>');\n    }\n    openTag && html.push('</',openTag,'>\\n');\n    return html.join('');\n}\n\nfunction DOMEditor (root) {\n}\n\nDOMEditor.prototype.setRTF = function (range, rtf) {\n    var html = rtf2html(rtf);\n    // staging element\n    body.innerHTML = html;\n    /*\n    var from=range.get('#'), till=range.get('#',from);\n    // clean DOM range\n    for(var pid=from; pid && pid!==till; pid=???)\n        body.removeChild(pid);\n    // install\n    while ()\n        body.insertBefore(newp,till); // TODO batch?\n    // recover selection\n    // */\n};\n\n\n//DOMEditor.prototype.getRTF = function (from, till, format, rtf) {\nfunction dom2rtf (from, till, format, rtf) {\n    rtf = rtf || [];\n    format = format || {};\n    if (till && from.parentNode!==till.parentNode) throw 'not siblings';\n    for(var i=from; i && i!==till; i=i.nextSibling)\n        if (i.nodeType===Document.ELEMENT_NODE) {\n            var child_format = {};\n            for(var key in format)\n                child_format[key] = format[key];\n            switch (i.nodeName.toUpperCase()) {\n                case 'B':  child_format['font-weight:'] = 'bold'; break;\n                case 'BR': // rtf.push(struct);\n                           rtf.push('\\n');\n                           break;\n                case 'UL': child_format['list'] = 'o'; break;\n                case 'LI': rtf.push('\\n'); break;\n                case 'P':  rtf.push(child_format,'\\n'); break;\n                case 'H1': child_format['head'] = 1;\n                           rtf.push(child_format,'\\n');\n                           break;\n            }\n            dom2rtf(i.firstChild,null,child_format,rtf);\n        } else if (i.nodeType===Document.TEXT_NODE) {\n            rtf.push(format);\n            rtf.push(i.nodeValue.replace(/\\n/g,'')); // TODO \\n spaces\n        } else {\n        }\n    return rtf;\n}\n\nfunction normalizeRTF (rtf) {\n    var ret = [], format = {}, prev = undefined;\n    for(var i=0; i<rtf.length; i++) {\n        var n = rtf[i];\n        if (!n)\n            continue;\n        if (n.constructor===String) {\n            if (prev && prev.constructor===String)\n                ret.push(ret.pop()+n);\n            else\n                ret.push(n);\n        } else if (n.constructor===Object) {\n            var match = true;\n            for(var key in n)\n                if (n[key]!==format[key]) {\n                    match = false;\n                    break;\n                }\n            if (match)\n                for(var key in format)\n                    if (n[key]!==format[key]) {\n                        match = false;\n                        break;\n                    }\n            format = n;\n            if (match)\n                continue;\n            if (prev && prev.constructor===Object)\n                ret.pop();\n            ret.push(n);\n        } else\n            continue;\n        prev = n;\n    }\n    return ret;\n}\n\nfunction Weave (chain) {\n    this.rtf = []; // TODO this.weave :)\n}\n\nWeave.prototype.setRTF = function (range, rtf) {\n    // SHORTCUT: equalize\n    var preex = this.getRTF(range);\n    // diff\n    var basic = dmp.diff_main(preexText,givenText);\n    // make ops\n    // pass to compare formattings\n    // (SEE NOTEBOOK 22feb Kiev)\n    // just effective formatting on new/remaining parts\n    this.text = '';\n    // apply\n};\n\nWeave.prototype.getRTF = function (range,spec) {\n    // find paragraph\n\n    // render according to the mode, base, version\n    // cumul formattings\n\n    return this.rtf;\n};\n/* jshint ignore: end  */\n","/home/travis/build/npmtest/node-npmtest-swarm/node_modules/swarm/lib/Html5Client.js":"\"use strict\";\n\nvar Swarm = module.exports = window.Swarm = {};\n\nSwarm.env = require('./env');\nSwarm.Spec = require('./Spec');\nSwarm.LongSpec = require('./LongSpec');\nSwarm.Syncable = require('./Syncable');\nSwarm.Model = require('./Model');\nSwarm.Set = require('./Set');\nSwarm.Vector = require('./Vector');\nSwarm.Host = require('./Host');\nSwarm.Pipe = require('./Pipe');\nSwarm.Storage = require('./Storage');\nSwarm.SharedWebStorage = require('./SharedWebStorage');\nSwarm.LevelStorage = require('./LevelStorage');\nSwarm.WebSocketStream = require('./WebSocketStream');\nSwarm.ReactMixin = require('./ReactMixin');\n\nSwarm.get = function (spec) {\n    return Swarm.env.localhost.get(spec);\n};\n\nvar env = Swarm.env;\n\nif (env.isWebKit || env.isGecko) {\n    env.log = function css_log(spec, value, replica, host) {\n        if (!host && replica && replica._host) {\n            host = replica._host;\n        }\n        if (value && value.constructor.name === 'Spec') {\n            value = value.toString();\n        }\n        console.log(\n                \"%c%s  %c%s  %c%O  %c%s @%c%s\",\n                \"color: #888\",\n                env.multihost ? host && host._id : '',\n                \"color: #024; font-style: italic\",\n                spec.toString(),\n                \"font-style: normal; color: #042\",\n                value,\n                \"color: #88a\",\n                (replica && ((replica.spec && replica.spec().toString()) || replica._id)) ||\n                (replica ? 'no id' : 'undef'),\n                \"color: #ccd\",\n                replica && replica._host && replica._host._id\n                //replica&&replica.spec&&(replica.spec()+\n                //    (this._host===replica._host?'':' @'+replica._host._id)\n        );\n    };\n}\n","/home/travis/build/npmtest/node-npmtest-swarm/node_modules/swarm/lib/LamportClock.js":"\"use strict\";\n\nvar Spec = require('./Spec');\n\n/** Pure logical-time Lamport clocks. */\nvar LamportClock = function (processId, initTime) {\n    if (!Spec.reTok.test(processId)) {\n        throw new Error('invalid process id: '+processId);\n    }\n    this.id = processId;\n    // sometimes we assume our local clock has some offset\n    this.seq = 0;\n};\n\nLamportClock.prototype.adjustTime = function () {\n};\n\nLamportClock.prototype.issueTimestamp = function time () {\n    var base = Spec.int2base(this.seq++, 5);\n    return base + '+' + this.id;\n};\n\nLamportClock.prototype.parseTimestamp = function parse (ts) {\n    var m = ts.match(Spec.reTokExt);\n    if (!m) {throw new Error('malformed timestamp: '+ts);}\n    return {\n        seq: Spec.base2int(m[1]),\n        process: m[2]\n    };\n};\n\n/** Lamport partial order  imperfect semi-logical*/\nLamportClock.prototype.checkTimestamp = function see (ts) {\n    var parsed = this.parseTimestamp(ts);\n    if (parsed.seq >= this.seq) {\n        this.seq = parsed.seq + 1;\n    }\n    return true;\n};\n\nLamportClock.prototype.time2date = function () {\n    return undefined;\n};\n\nmodule.exports = LamportClock;\n","/home/travis/build/npmtest/node-npmtest-swarm/node_modules/swarm/lib/MinutePreciseClock.js":"\"use strict\";\n\nvar Spec = require('./Spec');\n\n/** It is not always necessary to have second-precise timestamps.\n  * Going with minute-precise allows to fit timestamp values\n  * into 30 bits (5 base64, 2 unicode chars).\n  * More importantly, such timestamps increase incrementally for\n  * short bursts of events (e.g. user typing). That allows\n  * for sequence-coding optimizations in LongSpec.\n  * In case processes generate more than 64 events a minute,\n  * which is not unlikely, the optimization fails as we add\n  * 12-bit seq (2 base64, 1 unicode). */\nvar MinutePreciseClock = function (processId, timeOffsetMs) {\n    if (!Spec.reTok.test(processId)) {\n        throw new Error('invalid process id: '+processId);\n    }\n    this.id = processId;\n    // sometimes we assume our local clock has some offset\n    this.clockOffsetMs = 0;\n    this.lastIssuedTimestamp = '';\n    // although we try hard to use wall clock time, we must\n    // obey Lamport logical clock rules, in particular our\n    // timestamps must be greater than any other timestamps\n    // previously seen\n    this.lastTimeSeen = 0;\n    this.lastSeqSeen = 0;\n    if (timeOffsetMs) {\n        this.clockOffsetMs = timeOffsetMs;\n    }\n};\n\nvar epochDate = new Date(\"Wed, 01 Jan 2014 00:00:00 GMT\");\nMinutePreciseClock.EPOCH = epochDate.getTime();\n\nMinutePreciseClock.prototype.adjustTime = function (trueMs) {\n    // TODO use min historical offset\n    var localTime = new Date().getTime();\n    var clockOffsetMs = trueMs - localTime;\n    this.clockOffsetMs = clockOffsetMs;\n};\n\nMinutePreciseClock.prototype.minutes = function () {\n    var millis = new Date().getTime();\n    millis -= MinutePreciseClock.EPOCH;\n    millis += this.clockOffsetMs;\n    return (millis/60000) | 0;\n};\n\nMinutePreciseClock.prototype.issueTimestamp = function () {\n    var time = this.minutes();\n    if (this.lastTimeSeen>time) { time = this.lastTimeSeen; }\n    if (time>this.lastTimeSeen) { this.lastSeqSeen = -1; }\n    this.lastTimeSeen = time;\n    var seq = ++this.lastSeqSeen;\n    if (seq>=(1<<18)) {throw new Error('max event freq is 4000Hz');}\n\n    var baseTime = Spec.int2base(time, 4), baseSeq;\n    if (seq<64) {\n        baseSeq = Spec.int2base(seq, 1);\n    } else {\n        baseSeq = Spec.int2base(seq, 3);\n    }\n\n    this.lastIssuedTimestamp = baseTime + baseSeq + '+' + this.id;\n    return this.lastIssuedTimestamp;\n};\n\nMinutePreciseClock.prototype.parseTimestamp = function parse (ts) {\n    var m = ts.match(Spec.reTokExt);\n    if (!m) {throw new Error('malformed timestamp: '+ts);}\n    var timeseq=m[1]; //, process=m[2];\n    var time = timeseq.substr(0,4), seq = timeseq.substr(4);\n    if (seq.length!==1 && seq.length!==3) {\n        throw new Error('malformed timestamp value: '+timeseq);\n    }\n    return {\n        time: Spec.base2int(time),\n        seq: Spec.base2int(seq)\n    };\n};\n\nMinutePreciseClock.prototype.checkTimestamp = function see (ts) {\n    if (ts<this.lastIssuedTimestamp) { return true; }\n    var parsed = this.parseTimestamp(ts);\n    if (parsed.time<this.lastTimeSeen) { return true; }\n    var min = this.minutes();\n    if (parsed.time>min+1) { return false; } // bad clocks somewhere\n    this.lastTimeSeen = parsed.time;\n    this.lastSeqSeen = parsed.seq;\n    return true;\n};\n\n\nMinutePreciseClock.prototype.time2date = function () {\n    // parse etc\n};\n\nmodule.exports = MinutePreciseClock;\n","/home/travis/build/npmtest/node-npmtest-swarm/node_modules/swarm/lib/PostMessageStream.js":"\"use strict\";\n\nvar env = require('./env');\nvar Spec = require('./Spec');\n\n// This stream implementation uses postMessage to synchronize to\n// another IFRAME (use URIs like iframe:parent or iframe:elementId)\nfunction PostMessageStream(frameUri, origin, secret) {\n    this.origin = origin;\n    this.lstn = {};\n    if (frameUri.constructor === String) {\n        var m = frameUri.match(/^iframe:(\\w+)/i);\n        if (!m) {\n            throw new Error('invalid URL');\n        }\n        var frameId = m[1];\n        if (!frameId || frameId === 'parent') {\n            this.targetWindow = window.parent;\n        } else {\n            var i = document.getElementById(frameId);\n            if (!i) {\n                throw new Error('element unknown: ' + frameId);\n            }\n            if (!i.contentWindow) {\n                throw new Error('not an IFRAME');\n            }\n            this.targetWindow = i.contentWindow;\n        }\n    } else {\n        if (!frameUri.location) {\n            throw new Error('1st param: target frame');\n        }\n        this.targetWindow = frameUri;\n    }\n    var rnd = (Math.random() * 0xffffff) | 0;\n    var time = new Date().getTime() & 0xffffff;\n    this.secret = secret ||\n    ( Spec.int2base(time) + '~' + Spec.int2base(rnd) );\n    PostMessageStream.streams[this.secret] = this;\n    this.pending = null;\n    this.retries = 0;\n    this.retryInt = null;\n    if (!secret) { // make sure somebody listens on the other end\n        this.pending = '';\n        var self = this;\n        this.retryInt = setInterval(function () {\n            self.retryHandshake();\n        }, 100); // keep pinging the other frame for 1 second\n    }\n    this.write(''); // handshake\n}\nPostMessageStream.streams = {};\nPostMessageStream.re64 = /^([0-9A-Za-z_~]+)>/;\n\nPostMessageStream.prototype.retryHandshake = function () {\n    if (this.pending === null) { // it's OK\n        clearInterval(this.retryInt);\n        return;\n    }\n    if (this.retries++ > 10) {\n        clearInterval(this.retryInt);\n        this.lstn.error && this.lstn.error('no response from the frame');\n        this.close();\n    } else {\n        this.write('');\n        console.warn('retrying postMessage handshake');\n    }\n};\n\nPostMessageStream.prototype.onMessage = function (msg, origin) {\n    if (this.origin && origin !== this.origin) {\n        console.warn('mismatched origin: ', origin, this.origin);\n        return;\n    }\n    if (this.pending !== null) {\n        var p = this.pending;\n        this.pending = null;\n        p && this.write(p);\n    }\n    msg && this.lstn.data && this.lstn.data(msg);\n};\n\n// FIXME: explicitly invoke (security - entry point)\nwindow.addEventListener('message', function onPostMessage(ev) {\n    var msg = ev.data.toString();\n    var m = msg.match(PostMessageStream.re64);\n    if (!m) {\n        return;\n    }\n    var secret = m[1], json = msg.substr(secret.length + 1);\n    var stream = PostMessageStream.streams[secret];\n    if (!stream) {\n        if (!PostMessageStream.host) {\n            throw new Error('unknown stream: ' + secret);\n        }\n        stream = new PostMessageStream(ev.source, PostMessageStream.origin, secret);\n        stream.on('close', function cleanup() {\n            delete PostMessageStream.streams[secret];\n        });\n        PostMessageStream.host.accept(stream);\n    }\n    stream.onMessage(json, ev.origin);\n});\n\nPostMessageStream.listen = function (host, origin) {\n    PostMessageStream.host = host;\n    PostMessageStream.origin = origin;\n};\n\n\nPostMessageStream.prototype.on = function (evname, fn) {\n    if (evname in this.lstn) {\n        var self = this,\n            prev_fn = this.lstn[evname];\n        this.lstn[evname] = function () {\n            prev_fn.apply(self, arguments);\n            fn.apply(self, arguments);\n        };\n    } else {\n        this.lstn[evname] = fn;\n    }\n};\n\nPostMessageStream.prototype.write = function (data) {\n    if (this.pending !== null) {\n        this.pending += data || '';\n        data = '';\n    }\n    var str = this.secret + '>' + data;\n    this.targetWindow.postMessage(str, this.origin || '*');\n};\n\nPostMessageStream.prototype.close = function () {\n    var ln = this.lstn || {};\n    ln.close && ln.close();\n    delete PostMessageStream.streams[this.secret];\n};\n\nPostMessageStream.prototype.log = function (event, message) {\n    console.log('pm:' + this.frameId, event, message);\n};\n\nenv.streams.iframe = PostMessageStream;\nmodule.exports = PostMessageStream;\n","/home/travis/build/npmtest/node-npmtest-swarm/node_modules/swarm/lib/SharedWebStorage.js":"\"use strict\";\nvar Spec = require('./Spec');\nvar Storage = require('./Storage');\n\n\n/** SharedWebStorage may use localStorage or sessionStorage\n *  to cache data. The role of ShWS is dual: it may also\n *  bridge ops from one browser tab/window to another using\n *  HTML5 onstorage events. */\nfunction SharedWebStorage(id, options) {\n    this.options = options || {};\n    this.lstn = {};\n    this._id = id;\n    this.tails = {};\n    this.store = this.options.persistent ?\n        window.localStorage : window.sessionStorage;\n\n    this.loadLog();\n    this.installListeners();\n}\n\nSharedWebStorage.prototype = new Storage();\nSharedWebStorage.prototype.isRoot = false;\nmodule.exports = SharedWebStorage;\n\n\nSharedWebStorage.prototype.onOp = function (spec, value) {\n    var ti = spec.filter('/#');\n    var vo = spec.filter('!.');\n    if (!vo.toString()) {\n        return; // state, not an op\n    }\n    var tail = this.tails[ti];\n    if (!tail) {\n        tail = this.tails[ti] = [];\n    } else if (tail.indexOf(vo)!==-1) {\n        return; // replay\n    }\n    tail.push(vo);\n    this.emit(spec,value);\n};\n\n\nSharedWebStorage.prototype.installListeners = function () {\n    var self = this;\n    function onStorageChange(ev) {\n        if (Spec.is(ev.key) && ev.newValue) {\n            self.onOp(new Spec(ev.key), JSON.parse(ev.newValue));\n        }\n    }\n    window.addEventListener('storage', onStorageChange, false);\n};\n\n\nSharedWebStorage.prototype.loadLog = function () {\n    // scan/sort specs for existing records\n    var store = this.store;\n    var ti;\n    for (var i = 0; i < store.length; i++) {\n        var key = store.key(i);\n        if (!Spec.is(key)) { continue; }\n        var spec = new Spec(key);\n        if (spec.pattern() !== '/#!.') {\n            continue; // ops only\n        }\n        ti = spec.filter('/#');\n        var tail = this.tails[ti];\n        if (!tail) {\n            tail = this.tails[ti] = [];\n        }\n        tail.push(spec.filter('!.'));\n    }\n    for (ti in this.tails) {\n        this.tails[ti].sort();\n    }\n};\n\n\nSharedWebStorage.prototype.writeOp = function wsOp(spec, value, src) {\n    var ti = spec.filter('/#');\n    var vm = spec.filter('!.');\n    var tail = this.tails[ti] || (this.tails[ti] = []);\n    tail.push(vm);\n    var json = JSON.stringify(value);\n    this.store.setItem(spec, json);\n    if (this.options.trigger) {\n        var otherStore = !this.options.persistent ?\n            window.localStorage : window.sessionStorage;\n        if (!otherStore.getItem(spec)) {\n            otherStore.setItem(spec,json);\n            otherStore.removeItem(spec,json);\n        }\n    }\n};\n\n\nSharedWebStorage.prototype.writeState = function wsPatch(spec, state, src) {\n    var ti = spec.filter('/#');\n    this.store.setItem(ti, JSON.stringify(state));\n    var tail = this.tails[ti];\n    if (tail) {\n        for(var k=0; k<tail.length; k++) {\n            this.store.removeItem(ti + tail[k]);\n        }\n        delete this.tails[ti];\n    }\n};\n\nSharedWebStorage.prototype.readState = function (spec, callback) {\n    spec = new Spec(spec);\n    var ti = spec.filter('/#');\n    var state = this.store.getItem(ti);\n    callback(null, (state&&JSON.parse(state)) || null);\n};\n\nSharedWebStorage.prototype.readOps = function (ti, callback) {\n    var tail = this.tails[ti];\n    var parsed = null;\n    for(var k=0; tail && k<tail.length; k++) {\n        var spec = tail[k];\n        var value = this.store.getItem(ti+spec);\n        if (!value) {continue;} // it happens\n        parsed = parsed || {};\n        parsed[spec] = JSON.parse(value);\n    }\n    callback(null, parsed);\n};\n","/home/travis/build/npmtest/node-npmtest-swarm/node_modules/swarm/lib/SockJSServerStream.js":"\"use strict\";\n\nfunction SockJSStream(ws) {\n    var ln = this.lstn = {},\n        buf = [];\n\n    if (typeof ws === 'string') { // url passed\n        throw new Error('client-side connections not supported yet');\n    }\n    this.ws = ws;\n    if (ws.readyState !== 1/*WebSocket.OPEN*/) {\n        this.buf = buf; //will wait for \"open\"\n    }\n    ws.on('close', function () { ln.close && ln.close(); });\n    ws.on('data', function (msg) {\n        try {\n            ln.data && ln.data(msg);\n        } catch (ex) {\n            console.error('message processing fails', ex);\n            ln.error && ln.error(ex.message);\n        }\n    });\n}\n\nmodule.exports = SockJSStream;\n\nSockJSStream.prototype.on = function (evname, fn) {\n    if (evname in this.lstn) {\n        throw new Error('not supported');\n    }\n    this.lstn[evname] = fn;\n};\n\nSockJSStream.prototype.write = function (data) {\n    if (this.buf) {\n        this.buf.push(data.toString());\n    } else {\n        this.ws.write(data.toString());\n    }\n};\n\n//TODO SockJS-client env.streams.ws = env.streams.wss = SockJSStream;\n","/home/travis/build/npmtest/node-npmtest-swarm/node_modules/swarm/lib/SockJSStream.js":"\"use strict\";\n\nvar SockJS = require('sockjs-client');\nvar Swarm = require('swarm');\nvar env = Swarm.env;\n\nfunction SockJSStream(url) {\n    var self = this;\n    var ln = this.lstn = {};\n    this.url = url.replace(/^ws(s?):/, 'http$1:');\n    var ws = this.ws = new SockJS(this.url);\n    var buf = this.buf = [];\n    ws.onopen = function () {\n        buf.reverse();\n        self.buf = null;\n        while (buf.length) {\n            self.write(buf.pop());\n        }\n    };\n    ws.onclose = function () { ln.close && ln.close(); };\n    ws.onmessage = function (msg) {\n        ln.data && ln.data(msg.data);\n    };\n}\n\nSockJSStream.prototype.on = function (evname, fn) {\n    if (evname in this.lstn) {\n        var self = this,\n            prev_fn = this.lstn[evname];\n        this.lstn[evname] = function () {\n            prev_fn.apply(self, arguments);\n            fn.apply(self, arguments);\n        };\n    } else {\n        this.lstn[evname] = fn;\n    }\n};\n\nSockJSStream.prototype.write = function (data) {\n    if (this.buf) {\n        this.buf.push(data);\n    } else {\n        this.ws.send(data);\n    }\n};\n\nenv.streams.ws = env.streams.wss = SockJSStream;\nmodule.exports = SockJSStream;\n","/home/travis/build/npmtest/node-npmtest-swarm/node_modules/swarm/lib/swarm3-murmur.js":"\"use strict\";\n\n/**\n * JS Implementation of MurmurHash3 (r136) (as of May 20, 2011)\n *\n * @author <a href=\"mailto:gary.court@gmail.com\">Gary Court</a>\n * @see http://github.com/garycourt/murmurhash-js\n * @author <a href=\"mailto:aappleby@gmail.com\">Austin Appleby</a>\n * @see http://sites.google.com/site/murmurhash/\n *\n * @param {string} key ASCII only\n * @param {number} seed Positive integer only\n * @return {number} 32-bit positive integer hash\n */\n\nvar env = require('./env.js');\n\nenv.hashfn = function murmurhash3_32_gc(key, seed) {\n    var remainder, bytes, h1, h1b, c1, c2, k1, i;\n\n    remainder = key.length & 3; // key.length % 4\n    bytes = key.length - remainder;\n    h1 = seed;\n    c1 = 0xcc9e2d51;\n    c2 = 0x1b873593;\n    i = 0;\n\n    while (i < bytes) {\n        k1 =\n                ((key.charCodeAt(i) & 0xff)) |\n                ((key.charCodeAt(++i) & 0xff) << 8) |\n                ((key.charCodeAt(++i) & 0xff) << 16) |\n                ((key.charCodeAt(++i) & 0xff) << 24);\n        ++i;\n\n        k1 = ((((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16))) & 0xffffffff;\n        k1 = (k1 << 15) | (k1 >>> 17);\n        k1 = ((((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16))) & 0xffffffff;\n\n        h1 ^= k1;\n        h1 = (h1 << 13) | (h1 >>> 19);\n        h1b = ((((h1 & 0xffff) * 5) + ((((h1 >>> 16) * 5) & 0xffff) << 16))) & 0xffffffff;\n        h1 = (((h1b & 0xffff) + 0x6b64) + ((((h1b >>> 16) + 0xe654) & 0xffff) << 16));\n    }\n\n    k1 = 0;\n\n    switch (remainder) {\n    case 3:\n        k1 ^= (key.charCodeAt(i + 2) & 0xff) << 16;\n        /* falls through */\n    case 2:\n        k1 ^= (key.charCodeAt(i + 1) & 0xff) << 8;\n        /* falls through */\n    case 1:\n        k1 ^= (key.charCodeAt(i) & 0xff);\n\n        k1 = (((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16)) & 0xffffffff;\n        k1 = (k1 << 15) | (k1 >>> 17);\n        k1 = (((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16)) & 0xffffffff;\n        h1 ^= k1;\n    }\n\n    h1 ^= key.length;\n\n    h1 ^= h1 >>> 16;\n    h1 = (((h1 & 0xffff) * 0x85ebca6b) + ((((h1 >>> 16) * 0x85ebca6b) & 0xffff) << 16)) & 0xffffffff;\n    h1 ^= h1 >>> 13;\n    h1 = ((((h1 & 0xffff) * 0xc2b2ae35) + ((((h1 >>> 16) * 0xc2b2ae35) & 0xffff) << 16))) & 0xffffffff;\n    h1 ^= h1 >>> 16;\n\n    return h1 >>> 0;\n};\n","/home/travis/build/npmtest/node-npmtest-swarm/node_modules/swarm/lib/Text.js":"\"use strict\";\n\nvar Spec = require('./Spec');\nvar Syncable = require('./Syncable');\n\nvar Text = Syncable.extend('Text', {\n    // naive uncompressed CT weave implementation\n    defaults: {\n        weave: '\\n',\n        ids: {type:Array, value:'00000+swarm'},\n        text: '',\n        _oplog: Object\n    },\n\n    neutrals: {\n        state: function (spec, text, src) {\n            console.log('what?');\n        }\n    },\n    ops: {\n        insert: function (spec, ins, src) {\n            var w1 = [], w4 = [];\n            var vt = spec.token('!'), v = vt.bare;\n            var ts = v.substr(0, 5), seq = v.substr(5) || '00';\n            var seqi = Spec.base2int(seq);\n            for (var i = 0; i < this.weave.length; i++) {\n                var id = this.ids[i];\n                w1.push(this.weave.charAt(i));\n                w4.push(id);\n                if (id in ins) {\n                    var str = ins[id].toString();\n                    var k = i + 1;\n                    while (k < this.weave.length && this.ids[k] > vt.body) {\n                        k++;\n                    }\n                    if (k > i + 1) { // concurrent edits\n                        var newid = this.ids[k - 1];\n                        ins[newid] = ins[id];\n                        delete ins[id];\n                    } else {\n                        for (var j = 0; j < str.length; j++) {\n                            w1.push(str.charAt(j)); // FIXME overfill\n                            var genTs = ts + (seqi ? Spec.int2base(seqi++, 2) : '') + '+' + vt.ext;\n                            w4.push(genTs);\n                            if (!seqi) {\n                                seqi = 1; // FIXME repeat ids, double insert\n                            }\n                        }\n                    }\n                }\n            }\n            if (genTs) {\n                this._host.clock.checkTimestamp(genTs);\n            }\n            this.weave = w1.join('');\n            this.ids = w4;\n            this.rebuild();\n        },\n        remove: function (spec, rm, src) {\n            var w1 = [], w4 = [];\n            var v = spec.version();\n            for (var i = 0; i < this.weave.length; i++) {\n                w1.push(this.weave.charAt(i));\n                w4.push(this.ids[i]);\n                if (this.ids[i] in rm) {\n                    w1.push('\\u0008');\n                    w4.push(v);\n                }\n            }\n            this.weave = w1.join('');\n            this.ids = w4;\n            this.rebuild();\n        }\n    },\n    rebuild: function () {\n        /*var re = /([^\\u0008][\\u0008]+)|([^\\u0008])/g, m=[];\n         var text = [], tids = [], pos = 0;\n         while (m=re.exec(this.weave)) {\n         if (m[2]) {\n         text.push(m[2]);\n         tids.push(this.ids[pos]);\n         }\n         pos += m[0].length;\n         }\n\n         this.tids = tids;*/\n        this.text = this.weave.replace(/[^\\u0008][\\u0008]+/mg, '').substr(1);\n    },\n    set: function (newText) {\n        var patch = Text.diff(this.text, newText);\n        var rm = null, ins = null, weave = this.weave;\n        var re_atom = /[^\\u0008]([^\\u0008][\\u0008]+)*/mg;\n        var atom;\n\n        function skip(n) {\n            for (n = n || 1; n > 0; n--) {\n                atom = re_atom.exec(weave);\n            }\n        }\n\n        skip(1); // \\n #00000+swarm\n\n        for (var i = 0; i < patch.length; i++) {\n            var op = patch[i][0], val = patch[i][1];\n            switch (op) {\n            case '+':\n                ins || (ins = {});\n                ins[this.ids[atom.index]] = val;\n                break;\n            case '-':\n                rm || (rm = {});\n                for (var r = 0; r < val.length; r++) {\n                    rm[this.ids[atom.index + atom[0].length]] = true;\n                    skip();\n                }\n                break;\n            case '=':\n                skip(val.length);\n            }\n        }\n        rm && this.remove(rm);\n        ins && this.insert(ins);\n    }\n});\n\nText.diff = function diff(was, is) {\n    var ret = [];\n    // prefix suffix the rest is change\n    var pre = 0;\n    while (pre < was.length && pre < is.length && was.charAt(pre) === is.charAt(pre)) {\n        pre++;\n    }\n    var post = 0;\n    while (post < was.length - pre && post < is.length - pre &&\n    was.charAt(was.length - post - 1) === is.charAt(is.length - post - 1)) {\n        post++;\n    }\n    if (pre) {\n        ret.push(['=', was.substr(0, pre)]);\n    }\n    var ins = is.length - pre - post;\n    if (ins) {\n        ret.push(['+', is.substr(pre, ins)]);\n    }\n    var rm = was.length - pre - post;\n    if (rm) {\n        ret.push(['-', was.substr(pre, rm)]);\n    }\n    if (post) {\n        ret.push(['=', was.substr(pre + rm)]);\n    }\n    return ret;\n\n};\n\nmodule.exports = Text;\n","/home/travis/build/npmtest/node-npmtest-swarm/node_modules/swarm/lib/WebSocketStream.js":"\"use strict\";\n\nvar env = require('./env');\n\nfunction WebSocketStream(url) {\n    var self = this;\n    var ln = this.lstn = {};\n    this.url = url;\n    var ws = this.ws = new WebSocket(url);\n    var buf = this.buf = [];\n    ws.onopen = function () {\n        buf.reverse();\n        self.buf = null;\n        while (buf.length) {\n            self.write(buf.pop());\n        }\n\n    };\n    ws.onclose = function () { ln.close && ln.close(); };\n    ws.onmessage = function (msg) {\n        ln.data && ln.data(msg.data);\n    };\n    ws.onerror = function (err) { ln.error && ln.error(err); };\n}\n\nWebSocketStream.prototype.on = function (evname, fn) {\n    if (evname in this.lstn) {\n        var self = this,\n            prev_fn = this.lstn[evname];\n        this.lstn[evname] = function () {\n            prev_fn.apply(self, arguments);\n            fn.apply(self, arguments);\n        };\n    } else {\n        this.lstn[evname] = fn;\n    }\n};\n\nWebSocketStream.prototype.write = function (data) {\n    if (this.buf) {\n        this.buf.push(data);\n    } else {\n        this.ws.send(data);\n    }\n};\n\nenv.streams.ws = env.streams.wss = WebSocketStream;\nmodule.exports = WebSocketStream;\n"}